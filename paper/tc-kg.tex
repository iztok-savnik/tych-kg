\documentclass[runningheads]{llncs}

\pdfoutput=1
\usepackage{times}
\normalfont
\usepackage{latexsym}
\usepackage[T1]{fontenc}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphics}
\usepackage{color}
\usepackage{url}

% symbols
\newcommand{\ul}{\underline} 
\newcommand{\ol}{\overline} 
\newcommand{\darr}{\downarrow} 
\newcommand{\uarr}{\uparrow} 
\newcommand{\Darr}{\Downarrow} 
\newcommand{\Uarr}{\Uparrow} 
\newcommand{\llb}{\llbracket}
\newcommand{\rrb}{\rrbracket}
\newcommand{\vdasharr}{%
    \mathrel{%
        \vdash\hspace*{-5pt}%
        \raisebox{2.3pt}{\scalebox{.5}{\(\blacktriangleright\)}}%
    }%
}\newcommand{\D}{{\Delta}} 
\newcommand{\U}{{\cal U}} 
\newcommand{\B}{{\cal B}} 
\newcommand{\Lt}{{\cal L}} 
\newcommand{\St}{{\cal St}} 
\newcommand{\Pt}{{\cal Pt}} 
\newcommand{\Ot}{{\cal Ot}} 
\newcommand{\I}{{\cal I}} 
\newcommand{\Ii}{{\cal I}_i} 
\newcommand{\Ic}{{\cal I}_i} 
\newcommand{\Ip}{{\cal I}_p}
\newcommand{\V}{{\cal V}} 
\newcommand{\Vl}{{\cal V}_l} 
\newcommand{\Vi}{{\cal V}_i} 
\newcommand{\Vt}{{\cal V}_t} 
\newcommand{\Vp}{{\cal V}_p}
\newcommand{\T}{{\cal T}}
\newcommand{\Ti}{{\cal T}_i}
\newcommand{\Tt}{{\cal T}_t}
\newcommand{\cl}{\text{:}} 
\newcommand{\rdftype}{\text{rdf:type}} 
\newcommand{\rdfsubcl}{\text{rdfs:subClassOf}} 
\newcommand{\rdfsubclpl}{\text{rdfs:subClassOf+}} 
\newcommand{\rdfsubprop}{\text{rdfs:subPropertyOf}} 
\newcommand{\rdfsubproppl}{\text{rdfs:subPropertyOf+}} 
\newcommand{\rdfsdomain}{\text{rdfs:domain}} 
\newcommand{\rdfsrange}{\text{rdfs:range}} 
\newcommand{\finbox}{\phantom{.}\hfill\Box}
\newcommand{\nl}{\hfill\break}
\newcommand{\vb}[1]{\begin{small}\texttt{#1}\end{small}}
\newcommand{\lub}{l}
\newcommand{\memo}[1]{}
\newcommand{\notes}[1]{\noindent\begin{small}-- \emph{#1}\hfill\break\end{small}}
\newcommand{\nnotes}[1]{\indent\begin{small}-- \emph{#1}\hfill\break\end{small}}
\newcommand{\nnnotes}[1]{\indent\indent\begin{small}-- \emph{#1}\hfill\break\end{small}}
\newcommand{\anotes}[1]{\indent\begin{small}\phantom{-- }\emph{#1}\hfill\break\end{small}}
\newcommand{\ennotes}[1]{\indent\begin{small}-- \emph{#1}\hfill\end{small}}
 
\def\ojoin{\setbox0=\hbox{$\bowtie$}%
  \rule[-.02ex]{.25em}{.4pt}\llap{\rule[\ht0]{.25em}{.4pt}}}
\def\leftouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie}}
\def\rightouterjoin{\mathbin{\bowtie\mkern-5.8mu\ojoin}}
\def\fullouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie\mkern-5.8mu\ojoin}}

\pagestyle{headings}
\setcounter{tocdepth}{5} %show more in the toc

\begin{document}

\title{DRAFT! \\ On typing knowledge graphs}

\author{Iztok Savnik\inst{1}} 

\authorrunning{I. Savnik}

\institute{Department of computer science, \\
  Faculty of mathematics, natural sciences and information technologies, \\
  University of Primorska, Slovenia \\
  \email{iztok.savnik@upr.si}}

\maketitle

\begin{abstract}
...
  \keywords{knowledge graphs \and type systems.}
\end{abstract}

%\newpage
%\tableofcontents
%\newpage

\thispagestyle{headings}
%\tableofcontents
%\newpage




\section{Introduction}

%% Intro to KGs... what kind of language is it?
\notes{Introduction to knowledge graphs (KG)... \cite{Hogan2022,Ehrlinger2016}.}
\notes{KGs are becoming knowledge bases (KB)...}
\notes{What are the structural characteristics of KBs?}
\notes{What KBs can represent that (classical) data models can not.}
\notes{Relations between the knowledge bases and KGs.}

%% KG data model - knowledge representation language
\notes{What is structural part of KG?}
\notes{KG domain is complex because of the rich modelling constructs of a KR language.}
\notes{The static structure of a KG is built from the identifiers that are bound into triples.}
\notes{The identifiers and triples represent the basic structures of a KG, i.e., the values stored in a KG.}
\notes{They are the values of languages defined on top of KGs, such as the basic graph-patterns, SparQL queries, and if-then rules.}
\notes{Insight into the structure of KG.}
\notes{The classes form an ontology that can formally be represented as a poset.}
\notes{Consequently, triple types are also ordered in a poset.}
\notes{A KG includes triples that represent the values and triples that represent user-defined types that form the schema of a KG \cite{Savnik2025}.}
\notes{Denotational view of classes and type triples.}
\notes{The interpretations of classes and triple types form a poset based on the subset relation.}

% On stored or user-define typings of KG
\notes{Facts about the stored typings of the triples.}
\notes{In KGs we have types of individual objects represented as classes.}
\notes{Further, the types of the triples are the triples including types of triple components.}
\notes{A user-defined type of a triple is not linked directly to a triple.}
\nnotes{Types of triples are in a KG defined by specifying the types of identifiers that form triples.}
\nnotes{However, stored types of identifiers do not need to be those that appear in user-defined stored triple types.}
\nnotes{Hence, the types of ground triples must be derived from a KG by selecting the appropriate user-defined triple types from the types of components.}

%% Why types in KGs
\notes{What types are used for in a KG?}
\notes{Types can be used to verify the correctness of the ground triples and the structures that they form.}
\nnotes{The typing errors can appear in a KG if types of identifiers are specified incorrectly.}
\notes{Types define the context in a KG that allows placing (?) a structure of triples (sub-graph) in a KG.}
\notes{Disambiguation of property (predicate) placement. Later, binding of methods, etc.}
\nnotes{Typing the triple patterns is similar to typing ground triples \cite{Savnik2025}.}
\notes{Before we can define typing of languages that work with a KG, we have to be able to type a triple.}

%% About type checking in type theory
\notes{What is type checking? How it works...}
\notes{Types represent a higher-level description of ground triples.}
In type theory, types represent concepts that are used to classify the
values from a given language \cite{Pierce2002,Hindley1997}. Correct
typing assures that the functions are applied to correct parameters in
a program. The type-checking problem \\
\nnotes{Having a program verify that it conforms with the typing rules.}
\nnotes{In this process the rules can be applied in two directions.}
\nnotes{Type-assignment derives a type to an expression in a bottom-up manner.}
\nnotes{Here we use typing rules in the forward direction, hance type inference.}
\nnotes{Verifying that an expression adheres a given type uses typing rules in a backward direction.}
\nnotes{Here the rules decompose expressions into syntactic components and verifies recursively the types of comonents.}

% abstract of type checking KG ground triples
\notes{In order to check the types of a KG, the type of each ground triple has to be checked.}
\notes{There are two ways of computing the type of a triple.}
\notes{First, we can use types of identifiers representing the components of a triple.}
\nnotes{We call this type a \emph{ground type} since the types of identifiers classes from the bottom of the class ontology.}
\nnotes{Note that, because of the rule of subsumption \cite{Pierce2002}, the type of a ground triple is any triple type that is a supertype of a ground triple type.}
\notes{Second, we can select appropriate user-defined triple type $T$ such that the components of $T$ are the types of the components of the ground triple we are checking.}
\nnotes{The components of the user-defined triple types are noramlly from the top of the class ontology.}
\nnotes{Type checking of a ground triple is converted to checking the relationships between the ground type and user-defined type of a triple.} 
\notes{In all contexts we want to determine \emph{minimal type} of a triple, having the smallest interpretation.}

% differences to classical TC and tying data (structures)
%\notes{On differences of type-checking KGs to classical type-checking problem.}
%\notes{On intersection and union types and their use in type-checking KGs \cite{Pierce2002,Dezani2020,Pierce1991}.}
%\notes{TC is search in the KG space.}
%\notes{TC is an algorithm for selecting the appropriate type of a triple.}
%\notes{TC does not need variables as in TC of computer languages.}
  
%% Relations to other approaches
%\notes{The problem is in between type checking and type inference.}
%\notes{Using stored types of idents to infer the type of an object (ground triple) and then check how it relates to stored types of triples. }
%\notes{The idea is close to bideriectional typing \cite{Dunfield2021} because of inferring and checking.}
%\notes{In KGs we first infer as much as possible and then check inferred type with the stored types.}
%\notes{...}

%% Abstract of type-checking method
%\notes{Type-checking of KGs (abstract).}
%\notes{Type-checking of ground triples from a KG.}
%\notes{Three phases of type-checking ground triples.}
%\notes{First, a lub type $T_{lub}$ of a ground triple is derived,}
%\notes{Second, a MIN type $T_{min}$ of the stored triple types is computed.}
%\notes{Finally, a sub-type relationship between the types $T_{lub}$ and $T_{min}$ is investigated.}
%\notes{The type $T_{lub}$ restricts $T_{min}$ in cases that the propery of $t$ has multiple different meanings.}
%\notes{Typing triple patterns and BGP queries in further work.}
%\notes{Identifying errors in typing of a KG.}







\section{Preliminaries}


\subsection{Knowledge graph\label{sec:kg}}

This section defines a knowledge graph as a RDF graph \cite{rdf} using
RDF-Schema \cite{rdfschema} for the representation of the structural
part of a knowledge base. 

Let $I$ be a set of URI-s, $B$ be a set of blanks and $L$ be a set of
literals. Let us also define sets $S = I\cup\/B$, $P = I$, and
$O = I\cup\/B\cup\/L$. A \emph{RDF triple} is a triple
$(s,p,o)\in\/S\times\/P\times\/O$. A \emph{RDF graph}
$g\subseteq\/S\times\/P\times\/O$ is a set of triples. Set of all
graphs will be denoted as $G$.

The complete set of triples of a RDF graph is in the text denoted as
$\Delta$. We use $\Delta$ when we want to refer to the original set of
KG triples and not the data model of a KG presented in the following
Section.

%We say that RDF graph $g_1$ is \emph{sub-graph} of $g_2$, denoted
%$g_1 \sqsubseteq g_2$, if all triples in $g_1$ are also triples from
%$g_2$. 





\subsection{A data model of a KG}

To abstract away the details of the RDF data model we unify the
representation of knowledge graph by separating solely between the
identifiers and triples. The identifiers include the set of individual
identifiers and the set of class identifiers. The triples inlcude the
set of ground triples and the set of triple types.

%In view of the above formal representation of RDF triples, the
%complete set of identifiers is $\I=I\cup\/B\cup\/L$. The identifiers
%from $\I$ are classified into the sets including literals $\I_l$,
%individual (ground) identifiers $\I_i$, class identifiers $\I_c$,
%predicate identifiers $\I_p$.

However, since typing of a KG is based on the separation between the
values and the types we use the following classification of
identifiers and triples. The set of values $\V$ includes the
individual identifiers $\V_i$ and the individual (ground) triples
$\V_t$. To be able to refer to the specific subsets of $\V_i$ in the
rules we also introduce the set $\V_l\subseteq\V_i$, which denotes a
set of literal valus, and the set $\V_p\subseteq\V_i$ that refers to
the set of predicates from a KG. Finally, a set $\T_p\in\T_i$ standes
for all predicates of a KG that now have the role of types.

The set of valid types $\T$ of a KG comprises the class identifiers
$\T_i$, i.e. types of individual identifiers $\V_i$, and the triple
types $T_t$, i.e. the types of individual triples $\V_t$.

The set of class identifiers $\T_i$ related by subclass relation is a
poset forming an ontology of classes. Similarly also predicates, now
in the role of types, are ordered in a poset. The meaning oof class
identifiers is established by their interpretations. The
interpretatation of a class identifier $c$ comprises the instances of
a given class $c$ es well as the instances of all $c$'s sub-classes.

The individual triples include solely the individual identfifiers
$\V_i$ in places of S and O, and predicates $\V_p$ in the place of P
component of a triple. The types of individual triples are product
types $S*p*O$ where $S,O\in\T_i$ and $p\in\T_p$. The product types are
in our data model of a KG written as a triple $(S,p,O)$. The triple
types ordered by a subtype relation form a poset. The subtype relation
among the triple types in defined on the basis of the subtype relation
among the class identifiers.





\subsection{Typing rule language}

\memo{
In this paper we define typing of a data language used to represent an
ABOX \cite{Brachman2004KnowledgeRR} of a knowledge base given in a
form of a knowledge graph. The data language specifys the assertions
in the form of ground triples (ABOX) and the schema of assertions as
the types of triples (TBOX). The ground triples are the instances of
the triple types that altogether define the schema of a KG.}

In comparison to the data structures used in programming languages
\cite{Pierce2002,Hindley1997}, the conceptual schema of a KG is
complex in the sense that any data structure can be represented as a
graph. First, a KG includes an ontology of classes and
properties. Second, typing of ground identifiers is stored in a KG,
i.e., each ground identifier has one or more types represented as
class identifiers. Further, similarly to the \emph{roles}
\cite{Brachman1985} of a knowledge base, the predicates of a KG are
treated as objects that are included in a classification hierarchy of
predicates. For each predicate we have the definition of one or more
triple types stored in a KG. Finally, the predicates are inherited
through the classification hierarchy of classes and predicates.

Furthermore, the data language of a KG, which is based on RDF and
RDF-Schema \cite{rdf,rdfschema}, does not include variables as in
the case for the expressions of a programming language. All
information needed for typing a ground triple is available from a KG.

For the above presented reasons, we do not use standard typing rule
language \cite{Pierce2002,Hindley1997} that includes the context
$\Gamma$ where the types of the variables are stored. We use a
meta-language that is rooted in first order logic (abbr. FOL). The
rules are composed of a set of premises and a conclusion. The premises
can be expressions stating the membership of an object, typing
judgements in the form $o:T$, or expressions in the FOL. The
expressions of FOL can express complex premises such as the
requirements for the LUB and GLB triple types. The conclusion part of
the rule is a typing or subtyping judgment.

The symbols used in a rule are grounded by stating their membership in
a knowledge graph through the sets of identifiers ($\I_i$ and $\I_c$)
and triples ($\T_i$ and $\T_t$) defined in Section \ref{sec:kg}. When
we write $O\in\/S$ then we mean the \emph{existence} of $O$ in a set
$S$. We use universal quantification $\forall\/O\in\/S,\ p(O)$ when we
state that some property $p(O)$ holds for all objects $O$ from $S$.

Similar to \cite{Dunfield2021}, we differ between two interpretations
of rules. First, the \emph{generator} view of rules is the forward
interpretation where rules sythesize the types from the types derived
by premises. The premises of the rule are treated from the left to the
right. The quantification of the symbols binds the symbols up to the
last premise unless defined differently by the parentheses. Second,
the \emph{type-checking} view of the rules is the backward
interpretation. Given the symbol and its type, the construction of a
given type is checked by the rules.







\section{Typing identifiers}

%\memo{
%The set of identifiers $\I$ include ground identifiers $\I_g$, class
%identifiers $\I_c$, and the predicates (properties) $\I_p$ that are
%are both ground identifiers, since they are instances of rdf:Property,
%and similar to class identifiers, since they act as types and form an
%ontology of predicates.}

In this section we present the basic typing of ground identifiers
$\V_i$. The rules for typing ground identifiers are further used for
typing ground triples $\V_t$ in Section \ref{sec:triples}.  Typing of
literals $\V_l$ is described in Section \ref{sec:literals}. The rules
for deriving the stored types of ground identifiers are given in
Section \ref{sec:idents-stored}. Finally, the sub-typing relation
$\preceq$ is defined for the class identifiers $\T_i$ and the types of
ground identifiers are presented in Section \ref{sec:idents-typing}.

%However, before presenting the
%types of identifiers, we introduce the intersection and union types
%that are used for the description of the types of identifiers in the
%following Section \ref{sec:intsc-union}.

% \notes{Details.}
%\notes{1. First define base type of identifiers $:_1$ and stored subtyping relationship $\preceq_1$.}
%\notes{2. From the basis define the indent typing $:$ and subtyping rel $\preceq$ among identifiers.}
%\notes{3. Include the link between subtyping and typing.}
%\notes{4. Define lub type using $\land$ type for a given ground ident.}







\subsection{Typing literals\label{sec:literals}}

Literal values $\V_l\subseteq\V_i$ are the instances of literal types
$\T_l\subseteq\T_i$. The literal types are in RDF provided by the
RDF-Schema dictionary \cite{rdfschema}. RDF-Schema defines a list of
literal types, such as xsd:integer, xsd:string, or xsd:boolean.

The literals are composed of literal values and literal types. For
example, the literal
"literal"\textasciicircum\textasciicircum\/xsd:string includes the
literal value "365" and a type xsd:integer. Typing of literals is
defined by the following rule.

\begin{equation}
\dfrac{L\in\V_l\quad T\in\T_l\quad \text{"L"\textasciicircum\textasciicircum\/T}\in\Delta}
      {L:T}  
\end{equation}

The rule states that a literal value $L$ is of a type $T$ if a literal
"L"\textasciicircum\textasciicircum\/T is an element of a KG
$\Delta$. A literal type $T$ is referencing a type from the RDF-Schema
dictionary.






\subsection{Ground typing and subtyping of identifiers\label{sec:idents-stored}}

The typing expression $V:_1\/T$ is a \emph{ground typing} relation
$:_1$ that links a value $V\in\V$ to a ground type $T\in\T$. The
ground typing relation is a one-step typing relation based on typing
stored in a KG.

In this section we deal with the identifiers $I\in\V_i$ which are the
values of type $T\in\T_i$. The ground types are directly linked to the
ground identifiers via a stored typing relation in the form
$(I,rdf:type,T)\in\Delta$. The expression $I:_1\/T$ states that a
class identifier $T$ is a ground type of an individual identifier $I$.

The subtyping expression $T_1\preceq_1\/T_2$ defines a subtype
relationship between the types $T_1$ and $T_2$. In the case we deal
with the identifiers, the relation $T_1\preceq_1\/T_2$ denotes the
subclass relations since $T_1,T_2\in\T_i$. The relation $\preceq_1$ is
a one-step relation that is stored in $\Delta$. Note that a unique
notation for gound typing allows us to address differently the
\emph{stored} and the \emph{derived} types of ta KG.

%\notes{Partial ordering defined with stored schema triples in a database.}
%\notes{The relationships that poset $\preceq_1$ covers are rdfs:subClassOf and rdfs:subPropertyOf. }
%\notes{Identifiers included in $:_1$ are between ground idents and base classes.}
%\notes{This allows us to separate and also address separately the ssg and subtyping relationship.}

\memo{Oportunity to introduce ``mixed'' objects including ground and schema components.}

The rule for the one-step typing relation $:_1$ is defined using the
predicate rdf:type.

\begin{equation}
\label{rul:ident-1step-type}
\dfrac{I\in\V_i\quad T\in\T_i\quad (I,\text{rdf:type},T)\in\D}
      {I :_1 T}
\end{equation}

The individual entity $I$ can have more than one stored types. By
using Rule \ref{rul:ident-1step-type} as a generator, it synthesizes
all types $T_j^{j\in[1,n]}$ such that $I:_1\/T_j^{j\in[1,n]}$.

If we want to obtain all valid ground types of $I$, the rule can be
used either in some other rule that employs it as a generator, or we
can update above rule to generate a $\land$-type including all the
types of $I$ as presented in Section \ref{sec:intsc-union}.

The one-step subtyping relationship $\preceq_1$ is defined on
classes by using the RDF predicate rdfs:sub\-ClassOf as follows.

\begin{equation}
\label{rul:ident-1step-subtype}
\dfrac{C_1,C_2\in\T_i \quad (C_1,\text{rdfs:subClassOf},C_2)\in\D}
{C_1 \preceq_1\/C_2}
\end{equation}

The rule for the definition of the one-step subtyping relationship
$\preceq_1$ is based on the predicate rdfs:subPropertyOf.

\begin{equation}
\dfrac{P_1,P_2\in\T_p \quad (P_1,\text{rdfs:subPropertyOf},P_2)\in\D}
      {P_1\preceq_1\/P_2}
\end{equation}

The predicates have in the above rule the role of types in the sense
that they represent the names of the binary relations. 



\subsection{Typing and subtyping identifiers\label{sec:idents-typing}}

The one-step relationship $\preceq_1$ is extended with the
reflectivity, transitivity and antisymmetry to obtain the subtyping
relationship $\preceq$. The relation $\preceq$ forms a partial ordering of
class identifiers. The ground typing relation $:_1$ is then
extended with the \emph{rule of subsumption} presented as Rule
\ref{rul:typing-subsumption} to obtain a typing relation $:$.

First, the one-step relationship $\preceq_1$ is generalized to the
relationship $\preceq$ defined over class identifiers $\T_i$.

\begin{equation}
\label{rul:Ic-extended}
\dfrac{I_1,I_2\in\T_i \quad I_1\preceq_1\/I_2}
      {I_1 \preceq I_2}
\end{equation}

Next, the subtyping relationship $\preceq$ is reflexive.

\begin{equation}
\label{rul:Ti-reflexivity}
\dfrac{I\in\T_i}
      {I=I}
\end{equation}

The subtype relationship is also transitive. 

\begin{equation}
\label{rul:Ti-transitivity}
\dfrac{I_1,I_2,I_3\in\T_i\quad\/I_1\preceq\/I_2\quad\/I_2\preceq\/I_3}
      {I_1\preceq\/I_3}   
\end{equation}

Finally, the subtype relationship is asymmetric which is expressed
using the following rule. 

\begin{equation}
\label{rul:Ti-antisymmetry}
\dfrac{I_1,I_2\in\T_i \quad I_1\preceq\/I_2 \quad I_2\preceq\/I_1}
      {I_1=I_2}   
\end{equation}

As a consequence of the rules
\ref{rul:Ti-reflexivity}-\ref{rul:Ti-antisymmetry} the relation
$\preceq$ is a poset.

Knowledge graphs include a special class $\top$ that represents the
root class of the ontology. In RDF ontologies $\top$ is usually
represented by the predicate owl:Thing \cite{Hoffart2013}. The
following rule specifys that all class identifiers are more specific
than $\top$.

\begin{equation}
\dfrac{\forall\/S\in\T_i}
      {S\preceq\top}
\end{equation}

%\subsection{Typing of identifiers.}
The one-step typing relation $:_1$ is now extended to the typing
relation $:$ that takes into account the subtyping relation $\preceq$.
The following rule states that a stored type is a type.

\begin{equation}
\dfrac{I\in\V_i\quad\/C\in\T_i\quad\/I:_1\/C}
      {I:C}
\end{equation}

The link between the typing relation and subtype relation is provided
by adding a typing rule called \emph{rule of subsumption}
\cite{Pierce2002}.

\begin{equation}
\label{rul:typing-subsumption}
\dfrac{I\in\T_i\quad\/S,T\in\T_i\quad\/I:S\quad\/S\preceq\/T}
      {I:T}    
\end{equation}


\memo{Properties have dual role: they are instances and types at the same time.}
\memo{Present the features of properties from this point of view.}






\section{Intersection and union types\label{sec:intsc-union}}

\memo{
The meaning of the $\land$ and $\lor$ types can be defined through
their interpretations. The following definition expresses the
denotation of a $\lor$ type with the interpretations of its component
types. Suppose we have a set of types
$\forall\/i\in\/[1..n],\ T_i\in\tau$.

\begin{displaymath}
  \llbracket\lor[T_i^{i\in[1,n]}]\rrbracket_\D = \bigcup_{i\in[1..n]}\llbracket\/T_i\rrbracket_\D
\end{displaymath}

Similarly, the interpretation of a $\land$ type is the intersection of
the interpretations of its component types.

\begin{displaymath}
\llbracket\land[T_i^{i\in[1,n]}]\rrbracket_\D = \bigcap_{i\in[1..n]}\llbracket\/T_i\rrbracket_\D
\end{displaymath}}

\notes{CHECK: upper and lower bounds in the following rules.}

The meaning of the $\land$ and $\lor$ types can be seen through
their interpretations. The instances of the intersection type
$T_1\land\/T_2$ are objects belonging to both $T_1$ and $T_2$. The
type $T_1\land\/T_2$ is the greatest lower bound of the types $T_1$
and $T_2$. In general, $\land[T_i^{i\in[1,n]}]$ is the greatest lower
bound (abbr. GLB) of types $T_i^{i\in[1,n]}$
\cite{Pierce1991,Pierce1996}. The instances of the type
$\land[T_i^{i\in[1,n]}]$ form a maximal set of objects that belong to
all types $T_i$.

The rules for the $\land$ and $\lor$ types presented in this section
are general---they apply for the identifier types $\I_c$ and triple
types $\T_t$. The set of types $\tau=\I_c\cup\T_t$ is used to ground
the types in the rules.

The interpretation of a type $\land[T_i^{i\in[1,n]}]$ in included in
interpretation of every particular type $T_i$. Hence, the type
$\land[T_i^{i\in[1,n]}]$ is the greatest lower bound of types
$T_i^{i\in[1,n]}$. This is stated by the following rule.

\begin{equation}
\label{rul:land-preceq-elems}
\dfrac{T_i^{i\in[1,n]}\in\tau}
      {\land[T_i^{i\in[1,n]}] \preceq\/T_i^{i\in[1,n]}} 
\end{equation}

Further, the following rule states that if the type $S$ is a subtype
of every type $T_i^{i\in[1,n]}$ then $S$ is a subtype of
$\land[T_i^{i\in[1,n]}]$.

\begin{equation}
\label{rul:lbound-preceq-land}
\dfrac{S\in\tau\quad\/T_i^{i\in[1,n]}\in\tau\quad\/S\preceq\/T_i^{i\in[1,n]}}
      {S\preceq\land[T_i^{i\in[1,n]}]}  
\end{equation} 

The opposite to the above rule, the following rule states the
necessary conditions that must be met so that a type $T$ is a
supertype of a $\land$-type $\land[S_i^{i\in[1,n]}]$.
% this are upper bound types

\begin{equation}
\label{rul:land-preceq-ubound}
\dfrac{T\in\tau\quad\/S_i^{i\in[1,n]}\in\tau\quad\/S\in\{S_i^{i\in[1,n]}\}\quad\/S\preceq\/T}
      {\land[S_i^{i\in[1,n]}]\preceq\/T}  
\end{equation} 

The intersection and union types are dual. This can be seen also from
the duality of the rules for the $\land$ and $\lor$ types.

The instances from the union type $T_1\lor\/T_2$ are either the
instances of $T_1$ or $T_2$, or the instances of both
types. Therefore, $\lor[T_i^{i\in[1,n]}]$ is the least upper bound of
types $T_i^{i\in[1,n]}$ \cite{Pierce1991}.

\begin{equation}
\label{rul:lor-preceq-elems}
\dfrac{T_i^{i\in[1,n]}\in\tau}
      {T_i^{i\in[1..n]}\preceq\/\lor[T_i^{i\in[1,n]}]}
\end{equation}

Finally, the following rules defines the necessary conditions to be
met for a type $T$ to be a supertype of a type
$\lor[S_i^{i\in[1,n]}]$.

\begin{equation}
\label{rul:lor-preceq-ubound}
\dfrac{T\in\tau\quad\/S_i^{i\in[1..n]}\in\tau\quad\/S_i^{i\in[1..n]}\preceq\/T}
      {\lor[S_i^{i\in[1..n]}]\preceq\/T}  
\end{equation}

Again, the opposite rule that defines the premises that must hold so
that $S$ is a subtype of a type $\lor[T_i^{i\in[1,n]}]$.

\begin{equation}
\label{rul:lbound-preceq-lor}
\dfrac{T\in\tau\quad\/S_i^{i\in[1..n]}\in\tau\quad\/S\in\{S_i^{i\in[1..n]}\}\quad\/T\preceq\/S}
      {T\preceq\lor[S_i^{i\in[1..n]}]}  
\end{equation}

Note that besides checking the subtype relation between a type treated
as a whole and some logical type, Rules
\ref{rul:land-preceq-elems}-\ref{rul:lbound-preceq-lor} can be used to
check the subtyping among arbitrary logical types.


\memo{
Note that the interpretation of a class $C$ is a set of instances
$\llbracket\/C\rrbracket_\D=\{I\ |\ I\in\I_i\land\/I:C\}$. Further, the
interpretation of a triple type $T$ is the set of ground triples
$\llbracket\/T\rrbracket_\D=\{t\ |\ t\in\T_t\land\/t:T\}$\footnote{Triple
  types $\T_t$ are presented in the following Section
  \ref{sec:triples}.}\cite{Savnik2025}.\\}

\memo{Put together the base types of ground identifiers using $\land$ type.}
\memo{First, the base type of an ground identifier is the $\land$ of all base types.}
\memo{The \emph{base type} of a ground identifier is defined explicitely!}





\subsection{The join and meet types\label{sec:join-meet-types}}

The $\lor$ and $\land$ types are logical types defined through the
sets of instances. Given two types $T$ and $S$ we have a least upper
bound $S\lor\/T$, and a greatest lower bound $S\land\/T$ types where
$S\lor\/T$ denotes a minimal set of objects that are of type $S$
\emph{or} $T$ (or both), and $S\land\/T$ denotes a maximal set of
objects that are of type $S$ \emph{and} $T$.

A KG includes a stored poset of classes and triple types that
represent types of the individual objects and ground triples. The
poset can be used to compute a join $S\sqcup\/T$ and a meet
$S\sqcap\/T$. Usual definition of the join and meet operators is by
using a least upper bound and a greatest lower bound if they exist
\cite{Pierce2002}, respectively. However, in a KG we are also
interested in the upper bound and lower bound types
\cite{DaveyPriestley2002}. Let us present an example.

\begin{example}
  Let $P=(U,\preceq)$ be a partialy oredered set $P$ such that
  $U=\{a,b,c,d,e\}$ and the relation
  $\preceq=\{a\preceq\/c,a\preceq\/d,b\preceq\/c,b\preceq\/d,c\preceq\/e,d\preceq\/e\}$.
  The upper bounds of $S=\{a,b\}$ are the elements $c$ and $d$. Since
  there is no lower upper bounds, the upper bounds $\{c,d\}$ are
  minimal upper bounds. The least upper bound of $S$ is $e$.

  In the case that we remove the element $e$ from $P$ then $P$ does
  not have a least upper bound but it still has two minimal upper
  bounds $c$ and $d$. $\finbox$
\end{example}

The least upper bound (abbr. LUB) is by definition one element. It has
to be related to all upper bounds via the relationship $\preceq$.  On
the other hand, the most interesting upper and lower bounds are
minimal upper bounds (abbr. MUB) and maximal lower bounds (abbr. MLB)
\cite{Knudstorp2024}. They are lower than the least upper bound and
higher than the greatest lower bound, respectively. They represent
more detailed information about the parameter set of types $S$ than
the LUB type of $S$.

The join $J=\sqcup[T_i^{i\in[1,n]}]$ is a set of MUB types
$J_j^{j\in[1,m]}\in\/J$ such that $J_j$ is an upper bound with
$T_i^{i\in[1,n]}\preceq\/J_j$, and there is no such $L$ where
$T_i^{i\in[1,n]}\preceq\/L$ without also having $J_j\preceq\/L$. Since
we have a top type $\top$ defined in a KG, the join of arbitrary two
types always exists.

The meet of types $T_i^{i\in[1,n]}]$, $M=\sqcap[T_i^{i\in[1,n]}]$, is
a set of the maximal lower bound types $M_j^{j\in[1,m]}\in\/M$ such
that $M_j$ is lower bound with $M_j\preceq\/T_i^{i\in[1,n]}$, and all
other lower bounds $U$ with $U\preceq\/T_i^{i\in[1,n]}$ entail
$U\preceq\/M_j$. Note that the meet of the set of types from a KG does
not always exist.

The join type is related to the $\lor$-type. Given a set of types
$\{T_i^{i\in[1,n]}\}$, the join $J=\sqcup[T_i^{i\in[1,n]}]$ is a set
of types $J_j^{j\in[1,m]}\in\/J$ that are the minimal upper bounds
such that $T_i\preceq\/J_j$ for $i\in[1,n]$. On the other hand,
Rule \ref{rul:lor-preceq-elems} for the $\lor$-types states
$T_i\preceq\lor[T_i^{i\in[1,n]}]$. However, the join type and
$\lor$-type differ in the interpretation.
$$\llb\lor[T_i^{i\in[1,n]}]\rrb_\D=\bigcup_{i\in[1..n]}\llb\/T_i\rrb_\D\subseteq\bigcup_{j\in[1,m]}\llb\/J_j\rrb_\D=\llb\sqcup[T_i^{i\in[1,n]}]\rrb_\D$$

While the interpretation of the type $\lor[T_i^{i\in[1,n]}]$ includes
precisely the instances of all $T_i$, the interpretation of the type
$\sqcup[T_i^{i\in[1,n]}]$ contains the instances of minimal upper bound
types. The interpretation of $\sqcup[T_i^{i\in[1,n]}]$ can include
interpretations of classes that are not among $T_i^{i\in[1,n]}$.

A meet type of $T_i^{i\in[1,n]}$ may not exist in a poset of types
from a KG. In general, the meet types $M=\sqcap[T_i^{i\in[1,n]}]$
exist in a class ontology if the types $T_i^{i\in[1,n]}$ are
\emph{bounded below} \cite{Pierce2002} which means that there exists a
type $L$ such that $L\preceq\/T_i$ for all $i$. The meet types are not
frequent on the lower levels of a class ontology from a KG.

As in the case of the $\lor$-type and the join type, the semantics of
the $\land$-type is similar to the semantics of the meet type. A
$\land$-type is a type that implements logical view of the greatest
lower bound type. Differently, the meet types are based on the
concrete poset of KG types and represent concrete types though their
interpretation is contained in the interpretation of a
$\land$-type. The type $\land[T_i^{i\in[1,n]}]$ denotes the
intersection $\bigcap\/\llb\/T_i\rrb_\D$ while the interpretation of a
meet type $M_j\in\sqcap[T_i^{i\in[1,n]}]$ includes the interpretation
of the meet types from $M$. Note that the instances of the meet types
are in the intersection of the instances of types
$T_i^{i\in[1,n]}$. The set $\bigcap\/\llb\/T_i\rrb_\D$ can also
include objects that are not instances of any meet type from
$M$. Hence,
$$\llb\land[T_i^{i\in[1,n]}]\rrb_\D=\bigcap_{i\in[1..n]}\/\llb\/T_i\rrb_\D\supseteq\bigcap_{j\in[1,m]}\llb\/M_j\rrb_\D=\llb\sqcap[T_i^{i\in[1,n]}]\rrb_\D.$$

In type-checking the ground triples, the join types are used in the
procedure for checking the types derived bottom-up against the stored
schema of a KG as presented in Section \ref{sec:3-ground-types}. The
join as well as meet types are useful in the procedure for
type-checking basic graph patterns \cite{Savnik2025a}. The $\lor$ and
$\land$-types are logical types that can be simplified in the typing
positions of a graph pattern by using typing rules, and can be
approximated by using join and meet types to obtain a more precise
concrete type of a graph pattern variable.




\subsection{Typing with $\land$ and $\lor$ types}

\medskip
\notes{The use of $\land$ and $\lor$ types to describe identifiers.}
\nnotes{$\upsilon=\I_i\cup\T_i$ and $\tau=\I_c\cup\T_t$}
\nnotes{General rules are defined to work with identifiers and triples.}
\nnotes{Hence typing rules can be used to type idents and triples.}

\notes{For $V\in\upsilon$ gather ground types of identifiers with $\land$-type as $V:_{\darr}\land[T_i^{i\in[1,n]}]$.}
\nnotes{$V\in\upsilon\quad\forall\/T_i\in\tau,\ t:_{\darr}T_i$.}
\nnotes{The ground type of $V$ is a type $T_g=\land[T_i^{i\in[1,n]}]$.}
\ennotes{The following rule geathers all ground types of $V\in\upsilon$.}

\begin{equation}
\label{rul:land-1}
\dfrac{V\in\upsilon\quad\/T_i^{i\in[1,n]}\in\tau\quad\/V:_{\darr}T_i^{i\in[1,n]}}
      {V:_{\darr}\land[T_i^{i\in[1,n]}]}
\end{equation}

Let's have a look at $\land$ type composed of $V$'s ground types
$T_i^{i\in[1,n]}$ in the case $V\in\I_i$. In Yago \cite{Hoffart2013},
often $V$ has a set of very specific classes $C_s$ but also some
general classes $C_g$. The general classes $C_g$ are close to the
classes used in the stored triple types. If stored typing of $V$ is
correct, then $C_g$ includes the classes that are supertypes of
classes from $C_s$.

The ground type $\land[T_i^{i\in[1,n]}]$ can include pairs of types
$T_i\preceq\/T_k$ with $i\not=k$. Depending on the further use, we can
either compute the minimal or the maximal elements from the poset
$\{T_i^{i\in[1,n]}\}$ with respect to $\preceq$
\cite{DaveyPriestley2002}. The super-types of the minimal elements of
$\{T_i^{i\in[1,n]}\}$ include all valid types of $V$. Hence, we use
the set of minimal elements from $\{T_i^{i\in[1,n]}\}$ as the starting
point to explore the relations between the ground triple types and the
user-defined triple types of a triple $t$ including $V$ as a
component.

\memo{the type $\land[T_i^{i\in[1,n]}]$ It makes sense
either to compute MIN or MAX of $\land[T_i^{i\in[1,n]}]$ yielding
$\land[S_1..S_m]$ where $m\le\/n$ and
$S_j^{j\in[1,m]}\in\{T_i^{i\in[1,n]}\}$. The operator MIN computes
$S_j^{j\in[1,m]}$ such that each $S_j$ is minimal among
$T_i^{i\in[1,n]}$. The operator MAX computes $S_j^{j\in[1,m]}$ such
that each $S_j$ is maximal among $T_i^{i\in[1,n]}$. Note that in both
cases there are no pairs among $S_j^{j\in[1,m]}$ related by $\preceq$.}

The operator MIN is defined on a poset of types
$(\{T_i^{i\in[1,n]}\},\preceq)$. Given a set of types $\{T_i^{i\in[1..n]}\}$
the MIN operator retains types $S_j^{j\in[1,m]}\in\{T_i^{i\in[1,n]}\}$
such that ${\nexists}\/T_k^{k\in[1,n]}(T_k\prec\/S_j)$. All pairs of
types $S_k,S_l\in\{S_j^{j\in[1,m]}\}$ with $k\not=l$ are
\emph{incomparable}, i.e.,
$S_1\not\sim\/S_2\equiv\/S_1\not\preceq\/S_2\land\/S_1\not\succeq\/S_2$.
The logical rule for the operation MIN is as follows.

\begin{equation}
\label{rul:min}
\dfrac{V\in\upsilon\quad\/V:_\darr\land[T_i^{i\in[1,n]}]\quad\/S\in\/\{T_k^{k\in[1,n]}\}\quad\forall\/i\in[1,n],\ S\preceq\/T_i\lor\/S\not\sim\/T_i}
      {V:_{\Darr}S}
\end{equation}

The rule says that $S$ is a minimal type of a ground type
$\land[T_i^{i\in[1,n]}]$. $S$ is minimal since all other $T_i$ types are
either more general or equal ($\succeq$), or not related to $S$. The
rule generates all MIN types of $\land[T_i^{i\in[1,n]}]$.

The following rule is used for gathering all MIN types of
$\land[T_i^{i\in[1,n]}]$. The result is a conjunction of minimal types
$\land[S_1..S_m]$.

\begin{equation}
\label{rul:min-gather}
\dfrac{V\in\upsilon\quad\forall\/i\in[1,m],\ V:_\Darr\/S_i}
      {V:_{\Darr}\land[S_j^{j\in[1,m]}]}
\end{equation}


The rule for filtering $\land[T_i^{i\in[1,n]}]$ of all
$T_i\succeq\/T_j$ where $i\not=j$ by using algorithmic typing is
defined as follows. The algorithm implementing the operation MIN is
presented in Section \ref{sec:alg-MIN}.

\begin{equation}
\label{rul:alg-min}
\dfrac{V\in\upsilon\quad\vdasharr\/V:_\darr\land[T_i^{i\in[1,n]}]\quad\vdasharr\/\{S_j^{j\in[1,m}\}=\,\Darr\kern -3pt[T_i^{i\in[1,n]}]}
{\vdasharr\/V:_{\Darr}\land\/[S_j^{j\in[1,m]}]}
\end{equation}

Now we have a minimal ground type of a value $V$ in the form of a
conjunction of minimal types $S_i$ of $V$. The types that are
important from the perspective of typing computer languages defined on
values from a KG are the user-defined types of triples. The definition
of a user-defined triple type requires the knowledge about the meaning
of the binary relationship defined by a predicate---this is reflected
in the selection of the domain and range of the predicate.

The first step in verifying the relations between the ground and
user-defined types of a value $V$ is the computation of a join type
from a ground type of $V$. The join type of a ground type should be a
subtype of the user-defined types that describe the value $V$. If the
join type is not a subtype of the user-defined type then there is an
error in stored types of a value $V$.

Let us now present the typing rules that, given $V\in\upsilon$,
determine the join of $\{T_i^{i\in[1,n]}\}$ as
$V:\sqcup[T_i^{i\in[1,n]}]$. Recall from Section
\ref{sec:join-meet-types} that we defined the operation join as the
minimal upper bounds of a set $\{T_i^{i\in[1,n]}\}$. Let
$P=(\tau,\preceq)$ and $\{T_i^{i\in[1,n]}\}\subseteq\/P$. A join
$\sqcup[T_i^{i\in[1,n]}]$ is a set of minimal upper bounds
$\{S_j^{j\in[1,m]}\}$ that are related to all types $T_i^{i\in[1,n]}$
via $\preceq$, and are minimal.

%\nnotes{$\llb\land[T_i^{i\in[1,n]}]\rrb\subseteq\bigcup_{i\in[1..n]}\llb\/T_i\rrb\subseteq\llb\/T\rrb$.}
%\ennotes{A join type is used when we want to determine the user-defined type of $V$.}

Rules \ref{rul:join-logic}-\ref{rul:join-gather} present the logical
definition of the join type. The following Rule \ref{rul:join-logic}
determines one join type but can be used to generate all join types.


\begin{equation}
\label{rul:join-logic}
\dfrac{V\in\upsilon,\, \/V:_\darr\land[T_i^{i\in[1,n]}]\quad\/S\in\tau,\, T_i^{i\in[1,n]}\preceq\/S\quad\forall\/P\in\tau,\, (T_i^{i\in[1,n]}\preceq\/P\land\/S\preceq\/P)\lor\/P\not\sim\/S}
      {V:_\sqcup\/S}
\end{equation}

The individual join types derived by the above rule are gathered
into one $\land$ type of join types by using the following rule.

\begin{equation}
\label{rul:join-gather}
\dfrac{V\in\upsilon\quad\/S_i^{i\in[1,m]}\in\tau\quad\forall\/i\in[1,m],\ V:_\sqcup\/S_i}
{V:_{\sqcup}\land[S_i^{i\in[1,m]}]}
\end{equation}

The following Rule \ref{rul:join-alg} derives the complete join type
in one step. The operator join $\sqcup[T_i^{i\in[1,n]}]$ returns as a
result a set of minimal upper bound types of $T_i^{i\in[1,n]}$. Since
all the join types are valid types of $V$, we can group them into one
$\land$ type.

\begin{equation}
\label{rul:join-alg} 
\dfrac{V\in\upsilon\quad\vdasharr\/V:_\darr\land[T_i^{i\in[1,n]}]\quad\/\vdasharr\{S_j^{j\in[1,m]}\}=\sqcup[T_i^{i\in[1,n]}]}
      {\vdasharr\/V:_\sqcup\land[S_j^{j\in[1,m]}]}
\end{equation}

The join types are used as the starting point for searching the
correct user-defined type. In the case the predicate of has two
different definitions in two different contextes, then the paths from
join types to the domain and range classes determines the definition
of the triple type. The details are presented in Section
\ref{sec:stored-3types}.

%\notes{Integrate this explanation above.}
%\notes{Why computing a join type $S=\sqcup[S_1..S_n]$ of $\land[S_1..S_m]$?}
%\nnotes{Show how the $\land$ and $\sqcup$ types of $V$ are used to compute a type of $V$.}
%\nnotes{$V:_\sqcup\/S$ and there should be a path from $S$ to class components of stored triple types $T$.}
%\nnotes{... details about the above statement.}
%\nnotes{As such, $S$ is an approprite point to start searching stored types of $t$.}

\notes{Example from a KG.}
\notes{Let's have a look at $\sqcup$ types of $I$'s ground types $S_1..S_n$ from a KG. }
\nnotes{In many cases $I$ has a single type $S_1$ which is the same as the join type $S$.}
\nnotes{The super-classes of the join type $S$ have to be part of stored triple types}
\nnotes{to be selected as the types of subject or object.}
\nnotes{Often join type $S$ is close to the classes that are components of stored triple types.}
\notes{Can the situation with two super-predicates of a predicate $p$ lead to two different definitions of $p$?}










\section{Typing triples\label{sec:triples}}


\notes{We would like to type of a triple $t\in\T_i$.}
\notes{There are two basic aspects of a triple type.}
\nnotes{1. $t:T_g$ is computed bottom-up: from the stored types of triple components.}
\nnotes{2. $t:T_u$ can be computed from the user-defined types of properties.}
\nnotes{The relation $T_g\preceq\/T_u$ must hold if the typing of KG is correct.}
\nnotes{If the predicate $p$ of type $T_u$ is defined in multiple contexts, some of disjunctively}
\nnotes{linked components of $T_u$ may not be related to $T_g$.}
\nnotes{The filtering of $T_u$ is done by Rule \ref{rul:3-typing}.}

\notes{About the types that are computed bottom-up.}
\nnotes{Ground type of a triple is computed first by extending $:_\darr$ to triples.}
\nnotes{A triple can have multiple ground types $T_g=(\land[S_i^{i\in[1,k]}],p,\land[O_j^{j\in[1,m]}])$.}
\nnotes{Next, the join type $\sqcup[T_g]$ of ground type $T_g$ is derived.}
\nnotes{The type $\sqcup[T_g]$ is used as a stepping stone to determine the final type of $t$.}
\nnnotes{To be used for type-checking graph patterns.}

\notes{Stored triple types are user-defined types.}
\nnotes{Stored types for a predicate $p$ are defined via the predicates rdfs:domain and rdfs:range.}
\nnotes{From the top of the ontology, the stored type $:_\uarr$ is determined based on $p$.}
\nnotes{However, given $p$ we can have a triple type $(T_s,p,T_o)$ such that $T_s$ or $T_o$ are}
\anotes{defined for some $p'\succeq\/p$.}
\nnotes{Special case: $p'$ has two domains $T_s^1$ and $T_s^2$---type is then}
\anotes{$(T_s^1\lor\/T_s^2,p,\_)\equiv\/(T_s^1,p,\_)\lor(T_s^2,p,\_)$.}
\nnotes{$\T_\uarr=\{(T_s,p,T_o)| p\in\I_p\land(p,\text{rdfs:domain},T_s)\in\Delta\land(p,\text{rdfs:range},T_o)\in\Delta\}$} 
\nnotes{Derived types of the stored types are computed using Rule \ref{rul:typing-subsumption}.}
\nnotes{Derived types of $\T_\uarr$ include the complete top of the ontology }

\notes{Stored triple types for a given predicate $p$ are computed as MIN of valid stored types for $p$.}
\nnotes{The MIN types of types obtained using $:_\uarr$ are the smallest triple types}
\nnotes{including MIN classes as components.}
\nnotes{Stored type have to be minimal to have minimal interpretaton (e.g., type of a triple pattern).}
\nnotes{Finally, the type $:$ of $t$ is deterimned by summing alternative $:_\Darr$ types.}
\nnotes{Note there can be more than one $\Darr$-type.}
\nnotes{This happens when triple types include property that is defined in two different contexts.}

\notes{Interactions between the $\land/\lor$ types of triple components and triples must be added.}
\nnotes{Analogy between the types of functions in LC and types of triples.}
\nnotes{Show rules relating $\land/\lor$ types and triple types. Example.}
\nnotes{E.g., $(S_1\land\/S_2)*p*R = S_1*p*R\land\/S_2*p*R$.}
\nnotes{Are all rules covered?}

\notes{Predicates should be treated in the same way as the classes.}
\nnotes{They can have a rich hierarchy.}
\nnotes{\emph{Note:} Discussion on special role of predicates and their relations to classes?}
\nnotes{Mention Cyc as the practical KB with rich hierarchy of predicates.}





\subsection{Triple types\label{sec:3-types}}

A type of a triple $(s,p,o)\in\upsilon$ is a triple
$(D,p,R)\in\tau$ such that $s:D$ and $o:R$ holds. The types
$D$ and $R$ are type expressions that represent either a class or
a $\land$-type composed of classes.

The $\land$-types reflect the semantics of RDF-Schema \cite{rdfschema}
which permits the definition of multiple domains and ranges of the
predicate $p$. Consequently, each predicate $p$ has exactly one triple
triple type of the form
$$(\land[S_i^{i\in[1,n]}],p,\land[O_j^{j\in[1,m]}]).$$

\begin{example}
  If $p$ has two domains $D_1$ and $D_2$, and a single
range type $R$ then the type corresponding to $p$ is
$(D_1\land\/D_2,p,R)$. $\finbox$
\end{example}

\noindent
The interpretation of a triple type $(D,p,R)$ is defined as
follows.
$$\llb(D,p,R)\rrb_\Delta=\{(s,p,o)\mid\/s\in\llb\/D\rrb_\Delta\land\/o\in\llb\/R\rrb_\Delta \}$$

The subtype relationship among the triples is defined on the basis of
the subtype relationship among the classes and the $\land$-types
defined on classes, and predicates. The following rule defines the
relationship $\preceq$ beween two triple types.

\begin{equation}
\label{rul:3-subtype}
\dfrac{T_1\in\tau,\ T_1=(D_1,p_1,R_1)\quad T_2\in\tau,\ T_2=(D_2,p_2,R_2)\quad\/D_1\preceq\/D_2\quad\/p_1\preceq\/p_2\quad\/R_1\preceq\/R_2}
      {T_1\preceq\/T_2}
\end{equation}

It is obvious from the definition of the subtyping relationship among
the triple types that
$\llb\/T_1\rrb_\Delta\subseteq\llb\/T_2\rrb_\Delta$. Note that Rule
\ref{rul:3-subtype} handles the $\land$-types of the subject and
object through Rules
\ref{rul:land-preceq-elems}-\ref{rul:land-preceq-ubound}.







\subsection{Ground types of a triple\label{sec:3-ground-types}}

%
% deriving ground types of triples
% taking MIN types of ground types
% determine join type of minimal ground types
% 

\noindent
The ground types of a triple $t$ are either a stored ground type, a
minimal ground type, or a join ground type. The stored ground type
includes types that are stored in a KG. The minimal ground type then
consists of solely the minimal types from the stored ground
types. Finally, the join ground type is the conjunction of minimal
upper bound types \cite{Knudstorp2024}.
 
A ground type of an individual identifier $I$ is a class $C$ related
to $I$ by one-step type relationship $:_\darr$, as presented by Rule
\ref{rul:ident-1step-type}. In terms of the concepts of a knowledge
graph, $C$ and $I$ are related by the relationship rdf:type.

A ground type of a triple $t=(I_s,p,I_o)$ is a product type
$T_s*p*T_o$ that includes the ground types of $t$'s components $I_s$
and $I_o$, and the property $p$ which now has the role of a type. A
ground type of a triple is defined by the following rule.

\begin{equation}
\label{rul:3-ground}
\dfrac{t\in\upsilon,\ t=(I_s,p,I_o)\quad T_s,T_o\in\tau\quad I_s:_\darr\/T_s\quad I_o:_\darr\/T_o\quad p:_\darr\text{rdf:Property}}
      {t:_\darr\/T_s*p*T_o}
\end{equation}

The type $T_s$ is either a class identifier or a $\land$-type composed
of a conjunction of class identifiers. The predicates are treated
differently to the subject and object components of triples. The
predicates have the role of classes while they are instances of
rdf:Property.

The minimal ground type of a triple $t$ can be obtained by using the
minimal ground types of the triple components. 

\begin{equation}
\label{rul:3-min-ground}
\dfrac{t\in\upsilon,\ t=(I_s,p,I_o)\quad T_s,T_o\in\tau\quad I_s:_\Darr\/T_s\quad I_o:_\Darr\/T_o\quad p:_\darr\text{rdf:Property}}
      {t:_\Darr\/T_s*p*T_o}
\end{equation}

The component types $T_s$ and $T_o$ of the minimal ground type
$T_s*p*T_o$ can represent $\land$-types. The following rule transforms
a triple type including $\land$-types into a $\land$-type of simple
triple types composed of a class identifiers in place of $S$ and $O$
components. The rule is expressed in a general form by using the
typing relation "$:$" which can be replaced by any labeled typing
relation.

\begin{equation}
\label{rul:3-land-transform}
\dfrac{t\in\upsilon\quad t:\land[S_i^{i\in[1,n]}]*p*\land[R_j^{j\in[1,m]}]}
      {t:\bigwedge_{i\in[1,n], j\in[1,m]}[S_i*p*T_j]}
\end{equation}

The type in the conclusion of the rule is constructed by the Cartesian
product of the sets of types belonging to types of $S$ and $O$
components. Since each of types $S_i$ and $R_j$ are valid for the
components $S$ and $O$, respectively, then also the triple types from
the conclusion are valid.

The above decomposition of a triple type into a set of triple types is
useful when we check the ground types against the user-defined types
to select the valid user-defined type of a triple. This is detailed in
Section \ref{sec:stored-3types}.

Finally, the join of a set of ground types is a set of minimal upper
bound types. Similarly to the previous two rules, the join is defined
on the basis of joins of triple type components $S$ and $O$.

\begin{equation}
\label{rul:3-join}
\dfrac{t\in\upsilon,\ t=(I_s,p,I_o)\quad T_s,T_o\in\tau\quad I_s:_\sqcup\/T_s\quad I_o:_\sqcup\/T_o\quad p:_\darr\text{rdf:Property}}
      {t:_\sqcup\/T_s*p*T_o}
\end{equation}

The join type $T_s*p*T_o$ includes in the components $S$ and $O$ the
$\land$-types comprising one or multiple MUB classes. When we convert
this type into a conjunction of single MUB triple types then each MUB
triple type stands for all ground triple types of $t$.

We can easily see that each particular triple type is a MUB type since
it includes MUB types in its components. Since the MUB types of the
components are incomparable by $\preceq$ then also the MUB triple
types obtained by Rule \ref{rul:3-join} are incomparable.

\notes{All rules defined for the ground triple types rely on the computation of MIN and MUB types of its components.}
\notes{This is because the stored types as well as the stored poset relation $\preceq$ is defined on the class ontology.}

\memo{The types of $s$ and $o$ can be any classes $T_s$ and $T_o$ from
  ${\cal I}_c$, while the type of $p$ has to be a class $T_p$ that is
  a subclass of rdf:Property. The typing of a triple $t$ is correct
  since the interpretation of $T$ includes $t$.}

\memo{Moreover, the types $T$ that are derived by the above rule are
  minimal in the sense that given the information provided, i.e., the
  types of $t$'s components, their interpretations are minimal
  possible comparing them to the interpretations of all other derived
  types of $t$.}






\subsection{Stored triple types\label{sec:stored-3types}}

The stored triple types are types of triples defined by RDF-Schema
\cite{rdfschema} vocabulary. Each predicate has the domain and range
defined either directly, when domain and range are defined for the
predicate $p$, or indirectly, if the domain and range is defined for
$p$'s super-predicates and inherited to the predicate $p$.

When a KG is restricted by using RDF-Schema we can specify one or more
domain and range types. The semantics of RDF-Schema
\cite{rdfsemantics} interprets multiple domains and ranges with
$\land$-type. If $p$ has two domains $T_1$ and $T_2$ then $p$ can link
subjects $I$ that are of type $T_1$ \emph{and} $T_2$. The domain type
of $p$ is then $T_1\land\/T_2$, or, in terms of OWL \cite{owl},
owl:intersectionOf$(T_1\ T_2)$. The RDF-Schema does not allow the
definition of the domain of a predicate with the
$\lor$-type. Consequently, each predicate can have only one meaning.
  
\memo{
However, we often need a semantics of a predicate that allows the
definition of a predicate with multiple senses, depending on the
context of the predicate. One reason for adding $\lor$-types to a KG
can be the expressive power of KG. These KGs use owl:unionOf and
owl:intersectionOf to define more complex types of predicates.
Examples of such KGs are schema.org, EPCIS, DBpedia (in few cases) and
model transformation tools. Further, KGs that can define contexts and
use contextual reasoning also use $\land$ and $\lor$-types. The
contexts are often defined by RDF named graphs, e.g., DBpedia
\cite{Auer2007} and Linked Data \cite{ld-site}. Examples of KGs that
can define and use contexts are Cyc \cite{cyc}, Scone
\cite{Fahlman2011} and RACER \cite{Haarslev2012}.}

Let us now inspect the same problem from the perspecive of predicate
modelling. In the case one predicate stands for one sense of a
predicate, a polysemic predicate is specialized to sub-predicates
modelling different senses. In the case that predicates of a KG have
many senses, this representation can lead to predicate
explosion. However, the reasoning is simpler if all predicates have
unique meaning. % But the predicates are context insensitive.
The use of one sense for one predicate is detailed in Section
\ref{sec:stored-3types}.1.

The second way of modelling predicate sense is definition of the same
predicate in multiple contexts. The context can be defined in many
ways. Examples of contexts in KGs are RDF named graphs
\cite{Carroll2005}, microtheories of Cyc \cite{cyc}, and spaces in
Scone \cite{Fahlman2011}. The corresponding reasoners of KGs can
define and use contextes. A predicate can be defined differently in
different contexts but within one context we can only have one meaning
of a predicate.

The context (sense) of a predicate can also be defined by using triple
types including a given predicate. In other words, a sense of a
predicate depends on the context implemented by a triple type. The
definition of one predicate in multiple contexts is studied in
\ref{sec:stored-3types}.2.

\memo{
\notes{Whitin an ontology it seems that the triple type can be used, quite naturally, as the context of a predicate.}
\notes{The meaning of predicate is modelled by a triple type including concrete classes, types of domains and ranges.}
\notes{We have one triple type (predicate and types of S and O) mapped to one meaning.}
\notes{The representation requires using contextual reasoning \cite{cyc}.}
\notes{One of the pros is that contextual representation and reasoning is close to the natural language \cite{Fahlman2011}.}
\notes{Pitfalls of word sense disambiguation and contextual reasoning....}}

\memo{
How to define types of predicates when we have $\land$ and $\lor$-types possibly in different ontologies, RDF graphs, or KGs.
Different situations where and how the domains and ranges of predicate can be defined.
List some possibilities: diff ontologies, diff contexts, explicit definition of union in a context,...
We are goiung to use OWL syntax for the definition of domains and ranges.
For simplicity we assume that for each predicate we have a definition of the domain (range) in disjunctive noraml form.
}

\subsubsection{\ref{sec:stored-3types}.1 KGs with RDF-Schema.}
Let us first define the rules for finding a stored type of a triple in
the case RDF-Schema semantics is used in a KG. We first determine all
stored triple types for a given triple $t=(s,p,o)$. A stored type is
constructed by selecting triple types that are composed of a predicate
$p$ and the domain and range types linked to predicates
$p'\succeq\/p$. The domain and range types can be defined for the
predicate $p$ and/or inherited from the predicates $p'\succ\/p$.

\begin{equation}
\label{rul:3-stored1}
\dfrac{\begin{array}{c}
       t\in\upsilon,\, t=(s,p,o)\quad p_1,p_2\in\tau,\, p\preceq\/p_1\preceq\/p_2\quad \\
       T_i^{i\in[1,n]}\in\tau,\, (p_1,\text{domain},T_i)\in\/\Delta\quad S_j^{j\in[1,m]}\in\tau,\, (p_2,\text{range},S_j)\in\Delta
       \end{array}}
      {t:_\uarr\/\land[T_i^{i\in[1,n]}]*p*\land[S_j^{j\in[1,m]}]}
\end{equation}

The above rule generates the types of the domain and range of a
predicate $p$. The valid domain or range types of the predicate $p$
can be any of types defined as domain or range for some
$p'\succeq\/p$. Note that domain and range types can be defined for
different predicates $p_1$ and $p_2$ "above" $p$ ($p_1,p_2\succeq\/p$)
which have to be comparable, i.e., $p_1\sim\/p_2$. This condition
restricts the domain and range to be defined on the same path from $p$
to some maximal element $m$ of the predicate $p$ poset. In the second
part of the premise the domain and range types are gathered for the
selected predicates $p_1$ and $p_2$, respectively.

The above Rule \ref{rul:3-stored1} generates all valid stored types of
a triple $t$. From the set of all valid stored types of $t$ we select
the subset including only the minimal types. The following rule is a
logical judgment for a minimal stored triple type of a $t$. 

\begin{equation}
\label{rul:min-stored-type}
\dfrac{t\in\T_i\quad T\in\tau,\, t:_\uarr\/T\quad\/S_i^{i\in[1,n]}\in\tau,\, t:_\uarr\/S_i\quad T\preceq\/S_i\lor\/T\not\sim\/S_i}
      {t:_{\Darr}\/T}
\end{equation}

The first part of premise says that $t$ is a ground triple and there
exists $T\in\tau$ which is a type of $t$. The second part of the
premise requires that $T$ is the minimal type of all types $S$ of
$t$. In other words, there is no type $S_i^{i\in[1,n]}$ of $t$ that is
a subtype of $T$. Hence, $T$ is the minimal type of the stored triple
types of $t$. Note that if the stored typing of a KG (using
RDF.Schema) is correct then the condition $T\sim\/S_i$ is always
$true$.

In the case that our KG is restricted to RDF-Schema data model then
one predicate must represent exactly one meaning. Therefore, Rule
\ref{rul:min-stored-type} generates exactly one minimal
type. Furthermore, under the restrictions of RDF-Schema we can not
define a predicate $p$ with two meanings. If we would specify two
different domains or ranges of $p$ then reasoner would treat the
domain and range types as $\land$-types. Each instance of the domain
(range) type have to be an instance of all specified types of the
domain (range).

\subsubsection{\ref{sec:stored-3types}.2 KGs with the contextual representation.}

The collective findings of the research in the area of Cognitive
science \cite{Hollister2017} show that natural language is inherently
contextual, and the context is essential in the human representation
of knowledge and reasoning. 

While the current trend is to enforce exactly one meaning of a
predicates in KGs, the contextual representation and reasoning allows
the definition of multiple senses of a predicate. There are many
motivations for adopting contextual representation and reasoning in a
KG. First, with the evolvment of KGs there are many examples where a
KG is represented in the modular way spliting the dataset into parts
that correspond to the contexts. The meaning of a predicate can be
different in different contexts while the reasoner is able to
disambiguate among the different meanings of a predicate.
The practical examples of KGs using contexts include the named graphs
in DBpedia \cite{Auer2007}, Wiki Data \cite{vrandecic2014} and Yago
\cite{Hoffart2013}. Another example is Cyc \cite{cyc} that uses
microtheories to represent different contexts. Similarly to Cyc, Scone
\cite{Fahlman2011} is a KR system that can define spaces (contexts)
and uses contextual reasoning.

The second motivation for using contextual representation of KGs is
the problem of a predicate with mutiple senses represented with
multiple sub-predicates. In a query---whether expressed in natural
language, logic or as a database query---it is difficult to
disambiguate the correct sub-predicate for the particular query. The
alternative is that a user must explicitely select a correct sense of
a predicate (i.e., a sub-predicate) in the query.

Finally, a predicate can be compared to a mathematical function since
it represents a binary relation. In mathematics, a function is not
represented by its name only, but with a function type including,
besides the function name, also the types of its domain and
range. Types of function can disambiguate among the different
functions with the same name but different domain and range
types. Similarly, the types can be effectively used to disambiguate
the meaning of the predicate in a KG.

To be able to study the behavior of KG predicates with multiple senses
in the presence of triple types, we propose a minimal KR schema
language that includes the triple types stored in a KG as triples. In
the case there are more than one triple types including a predicate
$p$ then these are treated as alternatives. For example, if a KG
includes triples $(c_1,p,c_2)$ and $(c_3,p,c_4)$, where $c_i\in\I_c$,
then the type of ground triples including $p$ is
$c_1*p*c_2\lor\/c_3*p*c_4$.

Further, the proposed KR language can use $\land$ and $\lor$-types in
subject and object components of triple types. The $\land$ and
$\lor$-types are often implemented in KGs in the form of OWL type
constructors owl:intersectionOf and owl:unionOf\footnote{The OWL union
  and intersection type constructors are employed mostly in domain
  specific KGs like biomedical and genomic ontologies. In these
  scientific fields the knowledge base includes large ontologies where
  new classes can be defined as logical combinations of existing
  classes.}. The use of $\lor$-type in place of the domain or range
type is redundant since it can be expressed with multiple triple
types. Hence, the \emph{minimal} KR schema language includes solely
the triple types of the form
$$\land[c_i^{i\in[1,n]}]*p*\land[c_j^{j\in[1,m]}].$$

Let us now present the rules which derive the stored types of a ground
triple $t$ in the case our minimal KR schema language is used for the
definition of the KG schema. First, the following Rule
\ref{rul:3-stored2} generates all valid alternatives of stored triple
types given a triple $t$. Note that $D_i$ and $R_i$ are the types of
domains and ranges of $p$ that can stand for a $\land$-type.

\begin{equation}
\label{rul:3-stored2}
\dfrac{t\in\upsilon,\, t=(s,p,o)\quad T_i^{i\in[1,n]}\in\tau,\, T_i=(D_i,p,R_i)\quad\/T_i^{i\in[1,n]}\in\Delta}
      {t:_\uarr\/\lor[T_i^{i\in[1,n]}]}
\end{equation}

A stored triple type $\lor[T_i^{i\in[1,n]}]$ of $t$ is a disjunction
of all valid stored triple types of $t$. Similarly to Rules
\ref{rul:min}-\ref{rul:min-gather}, which are defined to find minimal
types of a set of classes, the following Rules
\ref{rul:3-min}-\ref{rul:3-min-gather} generate the set of minimal
stored triple types of a set including all valid stored tyes of $t$.

\begin{equation}
\label{rul:3-min}
\dfrac{t\in\upsilon\quad\/t:_\uarr\lor[T_i^{i\in[1,n]}]\quad\/S\in\/\{T_k^{k\in[1,n]}\}\quad\forall\/i\in[1,n],\ S\preceq\/T_i\lor\/S\not\sim\/T_i}
      {V:_{\Darr}S}
\end{equation}

The rule says that $S$ is a minimal stored triple type of a stored
triple type $\lor[T_i^{i\in[1,n]}]$. $S$ is minimal since all other
types $T_i$ are either more general or equal ($\succeq$), or not
related to $S$. The following rule gathers all minimal stored triple
types of $\lor[T_i^{i\in[1,n]}]$.

\begin{equation}
\label{rul:3-min-gather}
\dfrac{t\in\upsilon\quad\forall\/i\in[1,m],\ t:_\Darr\/S_i}
      {t:_{\Darr}\lor[S_j^{j\in[1,m]}]}
\end{equation}

The above rule is identical to the Rule \ref{rul:min-gather} except
that in this settings it handles triples and not identifiers. The
result is a disjunction of minimal stored triple types $S_j^{j\in[1,m]}$.

The following Rule \ref{rul:3-alg-min} is an algorithmic typing rule
for deriving a minimal type of a type $\lor[T_i^{i\in[1,n]}]$ by
computing a set of minimal stored triple types $\{S_j^{j\in[1,m]}\}$
from a poset of all valide stored triple types
$(T_i^{i\in[1,n]},\preceq)$. The algorithm implementing the operation
minimum is presented in Section \ref{sec:alg-MIN}.

\begin{equation}
\label{rul:3-alg-min}
\dfrac{t\in\upsilon\quad\vdasharr\/t:_\uarr\lor[T_i^{i\in[1,n]}]\quad\vdasharr\/\{S_j^{j\in[1,m}\}=\,\Darr\kern -3pt[T_i^{i\in[1,n]}]}
{\vdasharr\/t:_{\Darr}\lor\/[S_j^{j\in[1,m]}]}
\end{equation}

\memo{
\notes{If $p$ inherits from multiple $p'\succeq\/p$, then the above rule generates multiple types. Explain.}
\nnotes{The type is determined only if the domain and range of $p'\succeq\/p$ is defined.}
\nnotes{Otherwise, the domain and range shoud be $\top$. This should be included.}}

\memo{
Somewhere here, the inheritance should be noted.
Inheritance should be treated in knowledge graphs!
Predicates inherit in the same way as the classes.

\notes{What is the meaning of triple types that are \emph{not comparable} ($\not\sim$).}
\nnotes{1. This can be either that we have two $p$ roots with unrelated MIN triple types.}
\nnotes{This is possible only if $p$ is defined for semantically different concepts.}
\nnotes{2. Two $p$-rooted but unrelated stored types through multiple inheritance.}
\nnotes{Therefore, we can have more than one stored MIN types.}}

\memo{
The implementation view of the above rule is as follows. The schema
triples are obtained from the inherited values of the predicates
rdfs:domain and rdfs:range. The inherited values have to be the
closest when traveling from property $p$ towards the more general
properties.}







\subsection{Typing a triple}

\notes{Why using $\land$ and $\sqcap$ types for typing a triple $t$?}
\nnotes{We would like to check typing of a triple $t\in\T_i$.}
\nnotes{We compute first the ground type $T_g=\land[T_i^{i\in[1,n]}]$ and a stored type $T_s$ of $t$.}
\nnotes{The ground type $T_g$ is computed from the ground types of $t$'s components.}
\nnotes{The subtype relation should hold $T_g\preceq\/T_s$.}

\notes{Two ways of defining semantics.}
\notes{1) enumeration style: stored types are enumerated as alternatives ($\lor$).}
\notes{2) packed together: alternative types are packed in one $\bigvee$ type.}
\notes{One advantage of (1) is that individual glb types can be processed further individually.}
\notes{Advantage of (2) is the higer-level semantics without going in implementation.}

\notes{Stored types have to be related to all join ground types to represent the correct type of a triple.}
\notes{It seems it would be easier to check the pairs one-by-one using (1) in algorithms.}
\notes{In case of using complete types in the phases, types would further have to be processed by $\land,\lor$ rules.}

The type of a triple $t=(s,p,o)$ is computed by first deriving the
base type $T$ and the top type $S$ of $t$. Then, we check if $S$ is
reachable from $T$ through the sub-class and sub-property hierarchies,
i.e., $T\preceq\/S$.

\begin{equation}
\label{rul:3-typing}
\dfrac{t\in\T_i\quad T\in\T_t,\, t:_{\darr}T\quad S\in\T_t,\, t:_\uarr\/S\quad T\preceq\/S}
      {t:S}
\end{equation}

\medskip

\medskip
\notes{How to compute $T\preceq\/S$? Refer to position where we have a description.}
\notes{Order the possible derivations, gatherings (groupings) ... of types.}

\notes{Possible diagnoses.}
\notes{Components not related to a top type of a triple?}
\notes{Components related to sub-types of a top type?}
\notes{Above pertain to all components.}



\memo{
\subsection{Typing a graph}

\notes{What is a type of a graph?}
\nnotes{A type of a graph is a graph!}
\nnotes{It includes a set of triple types forming a schema graph.}

\notes{Typing schema triples?}
\nnotes{What can be checked?}
\nnotes{Is a schema triple properly related to the super-classes and types of components.}
\nnotes{Consistency of the placement of a class in an ontology.}
\nnotes{A class or predicate component not related to other classes?}
\nnotes{A class or predicate component attached to ``conflicting'' set of classes? ?}
\nnotes{Any other examples?}

\notes{Typing a graph.}
\nnotes{Checking whether triple types match in the meeting points.}
\nnotes{What is the type in meeting points of two triple types?}
\nnotes{Since a tye of a graph should present any legal triple in $\D$}
}


\section{Implementation of type-checking}


\subsection{Computing MIN type\label{sec:alg-MIN}}


\notes{We have a tuple $t=(s,p,o)$.}
\nnotes{The task is to compute MIN type of $t$'s stored types.}
\nnotes{The algorithm is using the predicates $p'\preceq\/p$ to obtain all domains and ranges of $p$.}



\notes{FUNCTION typeGlbStored ($p$: Property, $cnt$: Integer, $d_p$,$r_p$: Set): Type}
\notes{BEGIN}
\notes{if $d_p=\{\}$ then $d_p =  \{ c_s \mid (p,\text{rdfs:domain},c_s)\in\/G\}$}
\notes{if $r_p=\{\}$ then $r_p =  \{ c_o \mid (p,\text{rdfs:range},c_o)\in\/G\}$}
\notes{if $d_p\not=\{\}\land\/r_p\not=\{\}$ then }
\notes{RETURN $(\lor\/d_p,p,\lor\/r_p)$}
\notes{$ts = \{\}$}
\notes{for $p'$ ($(p,\text{rdfs:SubPropertyOf},p')\in\/G$)}
\notes{BEGIN}
\notes{$T_{p'} = typeGlbStored(p',cnt+1$,$d_p$,$r_p$)}
\notes{$ts = ts\cup\/\{T_{p'}\}$}
\notes{END}
\notes{RETURN $\lor\/ts$}
\notes{END}




\notes{Start with a set $\{p\}$ and close the set by using rdfs:superPropertyOf marking them with the ``distance'' from $p$.}
\nnotes{Gather all domain and range types of $p'\preceq\/p$ in $d_p$ and $r_p$, respectively, marking each domain and range class with the distance of the related $p'$.}
\nnotes{Generate types $\lor(s_t,p,o_t)$ where $s_t\in\/d_p$, $o_t\in\/r_p$ and both $s_t$ and $o_t$ are marked with the minimal values.}
\nnotes{Note that there can be more than one element $s_t$ (and $o_t$) marked with a minimal value in $d_p$ (and $r_p$). Hence Cartesian product of the selected domains and ranges are used to generate types $(s_t,p,o_t)$. }






\subsection{Computing join type\label{sec:alg-join}}

\notes{A ground type of a triple $t=(s,p,o)$ is a type $(s_t,p,o_t)$ such that $(s,\text{rdf:type},s_t)$ and $(o,\text{rdf:type},o_t)$.}
\notes{The sets of types $s_t$ and $o_t$ are stored in the sets $g_s$ and $g_o$, respectively.}
\notes{The ground type of $t$ is then $T_t=(\land\/g_s,p,\land\/g_o)$.}
\notes{The lub of a type $T_t$ is computed as follows.}

\notes{For each $s_t\in\/g_s$ ($o_t\in\/g_o$) compute a closure of a set $\{s_t\}$ ($\{o_t\}$) with respect to the relationship rdfs:superClassOf obtaining the sets $c_s$ and $c_o$.}
\notes{Each step of the closure newly obtained classes are marked with the number of steps if new in the set, and the maximum of both numbers of steps otherwise.}
\notes{The maximum guaranties the monotonicity: $s_t\prec_\darr\/s_t'\Rightarrow\/m(s_t)>m(s_t')$.}
\notes{Proof: Assume $m(s_t)<=m(s_t')$. Since $s_t\prec_\darr\/s_t'$ then $m(s_t')+1$ is maximum of $s_t$. Contradiction.}

\notes{The lub of $T_t$ is computed by intersecting all sets $c_s$ ($c_o$) obtained for each $s_t$ ($o_t$), yielding a lub type of $g_s$ ($g_o$).}
\notes{The intersection of sets is computed step-by-step. Initially, intersection is the first set $c_s$ ($c_o$) of some $s_t$ ($o_t$).}
\notes{In each step, a new set $c_s$ ($c_o$) for another $s_t$ ($o_t$) is intersected with previous result.}
\notes{The classes that are in the result (intersection) are merged by selecting the maximum number of closure steps for each class in the intersection.}
\notes{The reason for this is to obtain the number of steps within which all ground classes reach a given lub class.}

\notes{Finally, the lub classes are selected from the resulted intersection of all $c_s$ ($c_o$).}
\notes{The class with the smallest number of steps is taken. Then, it is deleted from the set together with all its super-classes.}
\notes{If set is not empty the previous step is repeated.}



\subsection{Relating LUB ground and MIN stored types}









\section{Related work}

\notes{Comparing typing relation in an OO model with a KG \cite{Pierce2002}.}
\notes{The values from KGs have similar structure to the values of object-oriented models.}
\notes{However, the predicates of a KG are more expressive than the data members of the classes.}
\notes{Similarly, the record types form a lattice under subtype relationship with least upper bound and greatest lower bound based on sets of record attributes.}

\notes{Include the differences between Pierce's (classical) sub-typing view of stored sub-class relationships among classes and the approach taken in this paper}
\notes{Pierce treats classes as generators of objects that inherit methods and data members from its super-class.}
\notes{The methods are inherited by copying the definitions in each subclass and then explicitely calling the method in the superclass.}
\notes{List the differences: classes are identifiers, there is a sub-class relationship included in a sub-typing relationship.}





\section{Conclusions}



% \section{Acknowledgments}
%
%The authors acknowledge the financial support from the Slovenian Research Agency (research core funding No. P1-00383).

\bibliographystyle{abbrv}
\bibliography{biblio}

\end{document}



= rules for identifiers
- assumtions
. suppose we have I, a set of identifiers from g
. suppose we have a 

- type-check literals


.................before 05/27/22....................

= (task) general picture
- we have graph pattern 
. a set of triples including consts and vars
- we derive types of TPs



- we derive types of GPs


= (task) determine a type of a TP
. type of TP without a predicate? use rdf:predicate.
. type of TP without the schema? use generalizations.
. type of TP with predicate? use a triple type defined as the schema.
. type of TP can be \cup of triple types (defined in the schema).


= (task) compute a type of a GP
. meeting points in GP: use \cap type constructor
. \cap of \cup of triple types can select one of triple types
. one triple type is selected by other oper of \cap


= (task) compute the type of a concrete triple
- we need a type of a concrete triple, e.g. for distribution
. if we have schema triple than it can be utilized
. obtain the type of each constant
. schema type, or, the most specific type?
