\documentclass[runningheads]{llncs}

\pdfoutput=1
\usepackage{times}
\normalfont
\usepackage{latexsym}
\usepackage[T1]{fontenc}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphics}
\usepackage{color}
\usepackage{url}

% symbols
\newcommand{\ul}{\underline} 
\newcommand{\ol}{\overline} 
\newcommand{\darr}{\downarrow} 
\newcommand{\uarr}{\uparrow} 
\newcommand{\Darr}{\Downarrow} 
\newcommand{\Uarr}{\Uparrow} 
\newcommand{\llb}{\llbracket}
\newcommand{\rrb}{\rrbracket}
\newcommand{\vdasharr}{%
    \mathrel{%
        \vdash\hspace*{-5pt}%
        \raisebox{2.3pt}{\scalebox{.5}{\(\blacktriangleright\)}}%
    }%
}\newcommand{\D}{{\cal D}} 
\newcommand{\U}{{\cal U}} 
\newcommand{\B}{{\cal B}} 
\newcommand{\Lt}{{\cal L}} 
\newcommand{\St}{{\cal St}} 
\newcommand{\Pt}{{\cal Pt}} 
\newcommand{\Ot}{{\cal Ot}} 
\newcommand{\I}{{\cal I}} 
\newcommand{\Ii}{{\cal I}_i} 
\newcommand{\Ic}{{\cal I}_c} 
\newcommand{\Ip}{{\cal I}_p}
\newcommand{\T}{{\cal T}}
\newcommand{\Ti}{{\cal T}_i}
\newcommand{\Tt}{{\cal T}_t}
\newcommand{\cl}{\text{:}} 
\newcommand{\rdftype}{\text{rdf:type}} 
\newcommand{\rdfsubcl}{\text{rdfs:subClassOf}} 
\newcommand{\rdfsubclpl}{\text{rdfs:subClassOf+}} 
\newcommand{\rdfsubprop}{\text{rdfs:subPropertyOf}} 
\newcommand{\rdfsubproppl}{\text{rdfs:subPropertyOf+}} 
\newcommand{\rdfsdomain}{\text{rdfs:domain}} 
\newcommand{\rdfsrange}{\text{rdfs:range}} 
\newcommand{\finbox}{\phantom{.}\hfill\Box}
\newcommand{\nl}{\hfill\break}
\newcommand{\vb}[1]{\begin{small}\texttt{#1}\end{small}}
\newcommand{\lub}{l}
\newcommand{\memo}[1]{}
\newcommand{\notes}[1]{\noindent\begin{small}-- \emph{#1}\\\end{small}}
\newcommand{\nnotes}[1]{\indent\begin{small}-- \emph{#1}\\\end{small}}
 
\def\ojoin{\setbox0=\hbox{$\bowtie$}%
  \rule[-.02ex]{.25em}{.4pt}\llap{\rule[\ht0]{.25em}{.4pt}}}
\def\leftouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie}}
\def\rightouterjoin{\mathbin{\bowtie\mkern-5.8mu\ojoin}}
\def\fullouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie\mkern-5.8mu\ojoin}}

\pagestyle{headings}
\setcounter{tocdepth}{5} %show more in the toc

\begin{document}

\title{Type-checking knowledge graphs}

\author{Iztok Savnik\inst{1}} 

\authorrunning{I. Savnik et al.}

\institute{Faculty of mathematics, natural sciences and information technologies, \\
  University of Primorska, Slovenia \\
  \email{iztok.savnik@upr.si}}

\maketitle

\begin{abstract}
This is an abstract...
  \keywords{type checking \and knowledge graphs \and RDF stores \and graph databases.}
\end{abstract}

\newpage
\tableofcontents
\newpage

\thispagestyle{headings}
%\tableofcontents
%\newpage




\section{Introduction}

%% Intro to KGs...
\notes{Introduction to knowledge graphs (KG)... \cite{Hogan2022,Ehrlinger2016}.}
\notes{KGs are becoming knowledge bases (KB)...}
\notes{What are the structural characteristics of KBs?}
\notes{What KBs can represent that (classical) data models can not.}
\notes{Relations between the knowledge bases and KGs.}

%% Why types in KGs
\notes{In KGs we have types of individual objects represented as classes.}
\notes{Further, the types of the triples are the triples including types of individual objects.}
\notes{Types represent a higher-level description of ground triples.}
\notes{Types can be used to verify the correctness of the ground triples and the structures that they form.}
\notes{Types define the context in a KG that allows placing (?) a structure of triples (sub-graph) in a KG.}
\notes{Disambiguation of property (predicate) placement. Later, binding of methods, etc.}

%% About type theory
\notes{On the type theory... \cite{Pierce2002,Hindley1997}.}
\notes{Classical type-checking problem in programming languages.}
\notes{On differences of type-checking KGs to classical type-checking problem.}
\notes{On intersection and union types and their use in type-checking KGs \cite{Pierce2002,Dezani2020,Pierce1991}.}

%% KG description language (domain)
\notes{KG domain is complex because KG is a knowledge representation (KR) language.}
\notes{We have a specific domain, i.e., a knowledge graph including nodes and triples.}
\notes{Abstract insight into the structure of KG.}
\notes{The classes form an ontology that can formally be represented as a poset.}
\notes{Consequently, triple types are also ordered in a poset.}
\notes{Denotational view of classes and type triples.}
\notes{The interpretations of classes and triple types form a poset based on the subset relation.}

%% Abstract of type-checking method
\notes{Type-checking of KGs (abstract).}
\notes{Type-checking of ground triples from a KG.}
\notes{Three phases of type-checking ground triples.}
\notes{First, a lub type $T_{lub}$ of a ground triple is derived,}
\notes{Second, a glb type $T_{glb}$ of the stored triple types is computed.}
\notes{Finally, a sub-type relationship between the types $T_{lub}$ and $T_{glb}$ is investigated.}
\notes{The type $T_{lub}$ restricts $T_{glb}$ in cases that the propery of $t$ has multiple different meanings.}
\notes{Typing triple patterns and BGP queries in further work.}
\notes{Identifying errors in typing of a KG.}

%% Relations to other approaches
\notes{The problem is in between type checking and type inference.}
\notes{Using stored types of idents to infer the type of an object (ground triple) and then check how it relates to stored types of triples. }
\notes{The idea is close to bideriectional typing \cite{Dunfield2021} because of inferring and checking.}
\notes{In KGs we first infer as much as possible and then check inferred type with the stored types.}
\notes{}






\section{Preliminaries}


\subsection{Knowledge graph\label{sec:kg}}

This section defines a knowledge graph as a RDF graph \cite{rdf} using
RDF-Schema \cite{rdfschema} for the representation of the structural
part of a knowledge base. 

Let $I$ be the set of URI-s, $B$ be the set of blanks and $L$ be the
set of literals. Let us also define sets $S = I\cup\/B$, $P = I$, and
$O = I\cup\/B\cup\/L$. A \emph{RDF triple} is a triple
$(s,p,o)\in\/S\times\/P\times\/O$. A \emph{RDF graph}
$g\subseteq\/S\times\/P\times\/O$ is a set of triples. Set of all
graphs will be denoted as $G$.

%We say that RDF graph $g_1$ is \emph{sub-graph} of $g_2$, denoted
%$g_1 \sqsubseteq g_2$, if all triples in $g_1$ are also triples from
%$g_2$. 

To abstract away the details of the RDF data model we unify the
representation of knowledge graph by separating solely between the
identifiers and triples. In view of the above formal representation of
RDF triples, the complete set of identifiers is
$\I=I\cup\/B\cup\/L$. The identifiers from $\I$ are classified into
the sets including literals $\I_l$, individual (ground) identifiers
$\I_i$, class identifiers $\I_c$, predicate identifiers $\I_p$.

The complete set of triples, referred to as $\T$, is classified into
the sets of individual (ground) triples $\T_i$, triple types $\T_t$
and abstract triples $\T_a$. The individual triples include solely the
individual identifiers $\I_i$ and predicates $\I_p$. The triple types
include only class identifiers $\I_c$ and predicates. Finally, the
abstract triples link individual and class identifiers in single
triples.



\subsection{Typing rule language}

In this paper we define typing of a data language used to represent a
TBOX \cite{Brachman2004KnowledgeRR} of a knowledge base given in a
form of a knowledge graph. The data language specifys the assertions
in the form of triples and the schema of assertions as the types of
triples. The ground triples are the instances of the triple types that
altogether define the schema of a KG.

In comparison to the data structures used in programming languages
\cite{Pierce2002,Hindley1997}, the data language of a KG is more
complex. First, a KG graph includes an ontology of classes and
properties. Second, typing of ground identifiers is stored in a KG,
i.e., each ground identifier has one or more types represented as
class identifiers. Further, the properties (predicates) of a KG are
treated as objects that are included in a classification hierarchy of
properties. For each property we have the definition of one or more
triple types stored in a KG. Finally, the properties (including triple
types) are inherited through the classification hierarchy of classes
and predicates.

Furthermore, the data language of a KG, which is based on RDF and
RDF-Schema \cite{rdf,rdfschema}, does not include variables as in
the case for the expressions of a programming language. All
information needed for typing a ground triple is available from a KG.

For the above presented reasons, we do not use standard typing rule
language \cite{Pierce2002,Hindley1997} that includes the context
$\Gamma$ where the types of the variables are stored. We use more
expressive meta-language that is rooted in first order logic
(abbr. FOL). The rules are composed of a set of premises and a
conclusion. The premises are either typing judgements in the form
$o:T$, or expressions in the FOL. The expressions of FOL can express
complex premises such as the requirements for the LUB and GLB triple
types. The conclusion part of the rule is a typing or subtyping
jufgement.

The rules are grounded in a knowledge graph through the sets of
identifiers and triples that are defined in Section
\ref{sec:kg}. In rules we specify the domain for each symbol used.
When we write $O\in\/S$ then we mean the \emph{existence} of $O$ in a
set $S$. We use universal quantification $\forall\/O\in\/S,\ p(O)$
when we state that some property $p(O)$ holds for all objects $O$ from
$S$.

Similar to \cite{Dunfield2021}, we differ between two interpretations
of rules. First, the \emph{generator} view of rules is the forward
interpretation where rules sythesize the types from the types derived
by premises. The premises of the rule are treated from the left to the
right. The quantification of the symbols binds the symbols up to the
last premise unless defined differently by the parentheses. Second,
the \emph{type-checking} view of the rules is the backward
interpretation. Given the symbol and its type, the construction of a
given type is checked by the rules.




\section{Typing identifiers}

The set of identifiers $\I$ include ground identifiers $\I_g$, class
identifiers $\I_c$, and the predicates (properties) $\I_p$ that are
are both ground identifiers, since they are instances of rdf:Property,
and similar to class identifiers, since they act as types and form an
ontology of predicates.

In this section we present typing of ground identifiers. The types of
ground identifiers are further used for typing ground triples in
Section \ref{sec:triples}. However, before presenting the types of
identifiers, we introduce the intersection and union types that are
used for the description of the types of identifiers in the following
Section \ref{sec:intsc-union}. Typing of literals is described in
Section \ref{sec:literals}. The rules for deriving the stored types of
ground identifiers are given in Section
\ref{sec:idents-stored}. Finally, the sub-typing relation $\preceq$ is
defined for the class identifiers and the complete types of ground
identifiers are presented in Section \ref{sec:idents-typing}.

%\notes{Details.}
%\notes{1. First define base type of identifiers $:_1$ and stored subtyping relationship $\preceq_1$.}
%\notes{2. From the basis define the indent typing $:$ and subtyping rel $\preceq$ among identifiers.}
%\notes{3. Include the link between subtyping and typing.}
%\notes{4. Define lub type using $\land$ type for a given ground ident.}







\subsection{Typing literals\label{sec:literals}}

Literals are the values of an atomic type. The atomic types are in RDF
provided by the RDF-Schema dictionary \cite{rdfschema}. RDF-Schema
defines a list of atomic types, such as xsd:integer, xsd:string, or
xsd:boolean.

Typing of the atomic types is determined by the following rule.

\begin{equation}
\dfrac{L\in\I_l\quad T\in\I_c,\quad \text{"L"\textasciicircum\textasciicircum\/T}\in\Lt}
      {L:T}  
\end{equation}

The rule states that a literal value $L$ is of a type $T$ if a literal
"L"\textasciicircum\textasciicircum\/T is an element of the set of
literals $\Lt$. A literal "L"\textasciicircum\textasciicircum\/T
includes a literal value $L$ and a literal type $T$ referencing a type
from the RDF-Schema dictionary. As an example, the literal
"365"\textasciicircum\textasciicircum\/xsd:integer includes the
literal value 365 and its type xsd:integer.





\subsection{Stored typing and subtyping of identifiers\label{sec:idents-stored}}

The expression $I:_\darr\/C$ states that a class $C$ is a type of an
individual identifier $I$. The expression $I_1\preceq_\darr\/I_2$
defines the subtype (sub-class) relationship between the class
identifiers $I_1$ and $I_2$. The index '$\darr$' in relations
$:_\darr$ and $\preceq_\darr$ denotes that the relations are stored in
a database---we refere to them as \emph{one-step} typing and subtyping
relations. Such notation allows us to address differently the
\emph{stored} and the \emph{derived} types of the graph database
schema.

%\notes{Partial ordering defined with stored schema triples in a database.}
%\notes{The relationships that poset $\preceq_1$ covers are rdfs:subClassOf and rdfs:subPropertyOf. }
%\notes{Identifiers included in $:_1$ are between ground idents and base classes.}
%\notes{This allows us to separate and also address separately the ssg and subtyping relationship.}

\memo{Oportunity to introduce ``mixed'' objects including ground and schema components.}

The rule for the one-step typing relation $:_\darr$ is defined using
the predicate rdf:type.

\begin{equation}
\label{rul:ident-1step-type}
\dfrac{I\in\Ii\quad I_c\in\Ic\quad (I,\text{rdf:type},I_c)\in \D}
      {I :_\darr I_c}
\end{equation}

The individual entity $I$ can have more than one stored types. By
using a generative interpretation, Rule \ref{rul:ident-1step-type}
synthesizes all types $I_c$ such that $I:I_c$. The rule can be used
either in some other rule that employ it as a generator, or we can
update above rule to generate a $\land$ type including all the types
of $I$ as presented in Section \ref{sec:intsc-union}.

A one-step subtyping relationship $\preceq_\darr$ is defined by means
of the RDF predicate rdfs:sub\-ClassOf in the following rule.

\begin{equation}
\dfrac{I_1,I_2\in\Ic \quad (I_1,\text{rdfs:subClassOf},I_2)\in \D}
{I_1 \preceq_\darr\/I_2}
\end{equation}

The rule for the definition of the one-step subtyping relationship
$\preceq_\darr$ is based on the predicate rdfs:subPropertyOf.

\begin{equation}
\dfrac{I_1,I_2\in\Ip \quad (I_1,\text{rdfs:subPropertyOf},I_2)\in \D}
      {I_1\preceq_\darr\/I_2}
\end{equation}





\subsection{Typing and subtyping identifiers\label{sec:idents-typing}}

The one-step relationship $\preceq_\darr$ is now extended with the
reflectivity, transitivity and asymmetry to obtain the relationship
$\preceq$. Relation $\preceq$ forms a partial ordering of class
identifiers. The ground typing relation $:_\darr$ is then extended
with the \emph{rule of subsumption}, presented as Rule
\ref{rul:typing-subsumption}, to obtain a typing relation $:$.

First, the one-step relationship $\preceq_\darr$ is generalized to the
relationship $\preceq$ defined over class identifiers $\I_c$.

\begin{equation}
\label{rul:Ic-extended}
\dfrac{I_1,I_2\in\I_c \quad I_1\preceq_\darr I_2}
      {I_1 \preceq I_2}
\end{equation}

Next, the subtyping relationship $\preceq$ is reflexive.

\begin{equation}
\label{rul:Ic-reflexivity}
\dfrac{I_c\in \I_c}
      {I_c\preceq\/I_c}
\end{equation}

The subtype relationship is also transitive. 

\begin{equation}
\label{rul:Ic-transitivity}
\dfrac{I_1,I_2,I_3\in\I_c \quad I_1\preceq\/I_2 \quad I_2\preceq\/I_3}
      {I_1\preceq\/I_3}   
\end{equation}

Finally, the subtype relationship is asymmetric which is expressed
using the following rule. 

\begin{equation}
\label{rul:Ic-antisymmetry}
\dfrac{I_1,I_2\in\I_c \quad I_1\preceq\/I_2 \quad I_2\preceq\/I_1}
      {I_1=I_2}   
\end{equation}

As a consequence of the rules
\ref{rul:Ic-reflexivity}-\ref{rul:Ic-antisymmetry} the relation
$\preceq$ is a poset.

Knowledge graphs include a special class $\top$ that represents the
root class of the ontology. In RDF ontologies $\top$ is usually
represented by the predicate owl:Thing \cite{Hoffart2013}. The
following rule specifys that all class identifiers are more specific
than $\top$.

\begin{equation}
\dfrac{\forall\/S\in\I_c}
      {S\preceq\top}
\end{equation}

%\subsection{Typing of identifiers.}
The stored typing relation $:_\darr$ is now extended to the typing
relation $:$ that takes into account the subtyping relation $\preceq$.
The following rule states that a stored type is a type.

\begin{equation}
\dfrac{I\in\I_i \quad C\in\I_c \quad I:_\darr\/C}
      {I:C}
\end{equation}

The link between the typing relation and subtype relation is provided
by adding a typing rule called \emph{rule of subsumption}
\cite{Pierce2002}.

\begin{equation}
\label{rul:typing-subsumption}
\dfrac{I\in\I_i\quad S\in\I_c\quad I:S \quad S\preceq\/T}
      {I:T}    
\end{equation}


\memo{Properties have dual role: they are instances and types at the same time.}
\memo{Present the features of properties from this point of view.}






\subsection{Intersection and union types\label{sec:intsc-union}}

The instances of the intersection type $T_1\land\/T_2$ are objects
belonging to both $T_1$ and $T_2$. The type $T_1\land\/T_2$ is the
greatest lower bound of the types $T_1$ and $T_2$. In general,
$\land[T_1\ldots\/T_n]$ is the greatest lower bound (abbr. GLB) of
types $T_1\ldots\/T_n$ \cite{Pierce1991,Pierce1996}. The instances of
the type $\land[T_1\ldots\/T_n]$ form a maximal set of objects that
belong to all types $T_i$.

The rules for the $\land$ and $\lor$ types presented in this section
are general---they apply for the identifier types $\I_c$ and triple
types $\T_t$. The set of types $\tau=\I_c\cup\T_t$ is used to ground
the types in the rules.

The instances of a type $\land[T_1..T_n]$ are the instances of all
particular types $T_i$. This is stated by the following rule. 

\memo{\begin{equation}
\dfrac{T_1,T_2\in\tau}
      {T_1\land\/T_2\preceq\/T_1}
\end{equation}

\begin{equation}
\dfrac{T_1,T_2\in\tau}
      {T_1\land\/T_2\preceq\/T_2}
\end{equation}}

\begin{equation}
\dfrac{\forall\/i\in[1..n],\ T_i\in\tau}
      {\land[T_1..\/T_n] \preceq\/T_i} 
\end{equation}

Further, the following rule states that if the type $S$ is more
specific than the types $T_1,\ldots\/,T_n$ then $S$ is more specific
then $\land[T_1..T_n]$.

\memo{\begin{equation}
\dfrac{S,T_1,T_2\in\tau\quad S\preceq\/T_1\quad\/S\preceq\/\/T_2}
      {S\preceq\/T_1\land\/T_2}  
\end{equation}}

\begin{equation}
\label{rul:intsc-gather}
\dfrac{S\in\tau\quad\forall\/i\in[1..n],\ T_i\in\tau\quad\/S\preceq\/T_i}
      {S\preceq\land[T_1..\/T_n]}  
\end{equation} 

The intersection and union types are dual. This can be seen also from
the duality of the rules for the $\land$ and $\lor$ types.

The instances from the union type $T_1\lor\/T_2$ are either the
instances of $T_1$ or $T_2$, or the instances of both
types. Therefore, $\lor[T_1\ldots\/T_n]$ is the least upper bound of
types $T_1,\ldots,\/T_n$ \cite{Pierce1991}.

\memo{\begin{equation}
\dfrac{T_1,T_2\in\tau}
      {T_1\preceq\/T_1\lor\/T_2}
\end{equation}

\begin{equation}
\dfrac{T_1,T_2\in\tau}
      {T_2\preceq\/T_1\lor\/T_2}
\end{equation}}

\begin{equation}
\label{rul:lor-1}
\dfrac{\forall\/i\in[1..n],\ T_i\in\tau}
      {T_i\preceq\/\lor[T_1..\/T_n]}
\end{equation}

Finally, if the type $T$ is more general than the types
$S_1,\ldots,\/S_n$ then $T$ is more general then
$\lor[S_1\ldots\/S_n]$.

\memo{\begin{equation}
\dfrac{T,S_1,S_2\in\tau\quad S_1\preceq\/T\quad\/S_2\preceq\/\/T}
      {S_1\lor\/S_2\preceq\/T}  
\end{equation}}

\begin{equation}
\label{rul:lor-2}
\dfrac{T\in\tau\quad\forall\/i\in[1..n],\ S_i\in\tau\quad\/S_i\preceq\/T}
      {\lor[S_1\ldots\/S_n]\preceq\/T}  
\end{equation}


\subsection{Semantics of $\land$ and $\lor$ types in KGs.}

The meaning of the $\land$ and $\lor$ types can be defined through
their interpretations. The following definition expresses the
denotation of a $\lor$ type with the interpretations of its component
types. Suppose we have a set of types
$\forall\/i\in\/[1..n],\ T_i\in\tau$.

\begin{displaymath}
  \llbracket\lor[T_1..T_n]\rrbracket_\D = \bigcup_{i\in[1..n]}\llbracket\/T_i\rrbracket_\D
\end{displaymath}

Similarly, the interpretation of a $\land$ type is the intersection of
the interpretations of its component types.

\begin{displaymath}
\llbracket\land[T_1..T_n]\rrbracket_\D = \bigcap_{i\in[1..n]}\llbracket\/T_i\rrbracket_\D
\end{displaymath}

Note that the interpretation of a class $C$ is a set of instances
$\llbracket\/C\rrbracket_\D=\{I\ |\ I\in\I_i\land\/I:C\}$. Further, the
interpretation of a triple type $T$ is the set of ground triples
$\llbracket\/T\rrbracket_\D=\{t\ |\ t\in\T_i\land\/t:T\}$\footnote{Triple
  types are presented in the following Section
  \ref{sec:triples}.}\cite{Savnik2025}.

\memo{Put together the base types of ground identifiers using $\land$ type.}
\memo{First, the base type of an ground identifier is the $\land$ of all base types.}
\memo{The \emph{base type} of a ground identifier is defined explicitely!}





\subsection{The join and meet types}

The $\land$ and $\lor$ types are logical types defined through the
sets of instances. Given two types $T$ and $S$ we have a greatest
lower bound $S\land\/T$, and a least upper bound $S\lor\/T$ types
where $S\land\/T$ denotes a maximal set of objects that are of type
$S$ \emph{and} $T$, and $S\lor\/T$ denotes a minimal set of objects
that are of type $S$ \emph{or} $T$ (or both).

A KG includes a stored poset of classes that represent types of the
individual objects. The poset can be used to compute a join type
$S\sqcap\/T$ and a meet type $S\sqcup\/T$ \cite{Pierce2002}. The join
type $J=S\sqcap\/T$ is the least type such that $S\preceq\/J$,
$T\preceq\/J$, i.e., for all types $U$, if $S\preceq\/U$ and
$T\preceq\/U$, then $J\preceq\/U$.

The meet type $M=S\sqcup\/T$ is the greatest type such that
$S\preceq\/M$, $T\preceq\/M$ and there is no such $L$ where
$S\preceq\/L$ and $T\preceq\/L$ without also having $L\preceq\/M$.
Since we have a top type $\top$ defined in a KG, the join of arbitrary
two types always exists. However, the meet of two arbitrary types may
not exist always. 

The join type is related to the $\lor$-type. Given a set of types
$\{T_1\ldots\/T_n\}$, the join type $T=\sqcup[T_1..T_n]$ represents a
LUB type such that $T_i\preceq\/T$ for all $i$. On the other hand,
Rule \ref{rul:lor-1} for the $\lor$-types states
$T_i\preceq\lor[T_1..T_n]$. However, the join type and $\lor$-type
differ in the interpretation. 
$$\llb\lor[T_1..T_n]\rrb_\D=\bigcup_{i\in[1..n]}\rrb\/T_i\rrb_\D\subseteq\llb\/T\rrb_\D=\llb\sqcup[T_1..T_n]\rrb_\D$$

While the interpretation of the type $\lor[T_1..T_n]$ includes
precisely the instances of all $T_i$, the type $T$ is a LUB class and
the interpretation of $T=\sqcup[T_1..T_n]$ can include interpretations
of classes that are not among $[T_1..T_n]$.

A meet type of $[T_1..T_n]$ may not exist in a poset of classes from a
KG. In general, a meet type $M=\sqcap[T_1..T_n]$ exists in a class
ontology if the types $T_1..T_n$ are \emph{bounded below} which means
that there exists a type $L$ such that $L\preceq\/T_i$ for all
$i$. The bounded meet types \cite{Pierce2002} are not frequent on the
lower levels of a class ontology from a KG.

Similarly to the $\lor$-type and the join type, the semantics of the
$\land$-type is similar to the semantics of meet type. Both of them
define a GLB type. The type $\land[T_1..T_n]$ denotes the intersection
$\bigcap\/\llb\/T_i\rrb_\D$ while the interpretation of a meet type
$M=\sqcap[T_1..T_n]$ includes solely the interpretation of $M$. The
set $\bigcap\/\llb\/T_i\rrb_\D$ can also include objects that are not
instances of $M$. Hence,
$$\llb\sqcap[T_1..T_n]\rrb_\D=\llb\/M\rrb_\D\subseteq\llb\land[T_1..T_n]\rrb_\D=\bigcap_{i\in[1..n]}\/\llb\/T_i\rrb_\D.$$
In type-checking the ground triples, the join types are used in the
procedure for checking the types derived bottom-up against the stored
schema of a KG as presented in Section \ref{sec:3-ground-types}. The
join as well as meet types are very useful in the procedure for
type-checking basic graph patterns \cite{Savnik2025a}. The $\lor$ and
$\land$-types are logical types that can be simplified in the typing
positions of a graph pattern by using typing rules, and can be
approximated by using join and meet types to obtain a more precise
type of a GP variable.

\medskip
\notes{The use of $\land$ and $\lor$ types to describe identifiers.}
\notes{For $I\in\I_i$ gather ground types of identifiers with $\land$-type as $I:\land[S_1..S_n]$.}
\notes{For $I\in\I_i$ compute a join type of $S_1..S_n$ as $I:\sqcup[S_1..S_n]$.}
\nnotes{A join type $S_g=\sqcup[S_1..S_n]$ is the LUB type of $[S_1..S_n]$.}
\nnotes{$\bigcup_{i\in[1..n]}\llb\/S_i\rrb\subseteq\llb\/S_g\rrb$}
\nnotes{In a class poset we can have more than one LUB types for a given set of types.}

\notes{Why computing a join type $S_g=\sqcup[S_1..S_n]$ for $\land[S_1..S_n]$?}
\nnotes{We would like to check typing of a triple $t\in\T_i$.}
\nnotes{We compute first the ground type $T_g=\land[T_1..T_m]$ and a stored type $T_s$ of $t$.}
\nnotes{The ground type $T_g$ is computed from the ground types of $t$'s components.}
\nnotes{The subtype relation should hold $T_g\preceq\/T_s$.}

\notes{Why computing a LUB type of $T_g=\land[T_1..T_m]$?}
\nnotes{To get a LUB type of ground types $T_g$ of $t$, i.e., one representative type...}
\nnotes{we compute the ground types $S_g$ of $T_g$'s components.}
\nnotes{$T_g$ should be close to the level of stored triple types $T_s$ of $t$.}
\nnotes{As such, $T$ is an approprite point to start searching stored types of $t$.}







\section{Typing triples\label{sec:triples}}

\notes{There are two basic aspects of a triple type.}
\notes{First, the type is computed bottom-up: from the stored types of triple components.}
\notes{Second, the type can be computed top-down: from the user-defined domain/range types of properties.}

\notes{About the types that are computed bottom-up.}
\notes{Ground type of a triple is computed first using $:_\darr$.}
\notes{Next, the lub type of a triple is derived using $:_\sqcup$.}

\notes{About the stored types that are computed as glb of valid stored types.}
\notes{From the top side of the ontology, the stored type $:_\uarr$ is determined based on $p$.}
\notes{The glb types of all types obtained using $:_\uarr$ obtaining a glb type $:_\sqcap$.}
\notes{Finally, the type $:$ of $t$ is deterimned by summing alternative $:_\uarr$ types.}

\notes{Interactions between the $\land/\lor$ types of triple components and triples must be added.}
\notes{Analogy between the types of functions in LC and types of triples.}
\notes{Show rules relating $\land/\lor$ types and triple types. Example.}
\notes{E.g., $(S_1\land\/S_2)*p*R = S_1*p*R\land\/S_2*p*R$.}
\notes{Are all rules covered?}

\notes{Predicates should be treated in the same way as the classes.}
\notes{They can have a rich hierarchy.}
\notes{\emph{Note:} Where to include discussion on special role of predicates and their relations to classes?}
\notes{Mention Cyc as the practical KB with rich hierarchy of predicates.}



\subsection{Product types}



\subsection{Deriving a ground type of a triple\label{sec:3-ground-types}}

\noindent
A ground type of an individual identifier $i$ is a class $C$ related
to $i$ by one-step type relationship $:_\darr$ denoting a ground
type. In terms of the concepts of a knowledge graph, $C$ and $i$ are
related by the relationship rdf:type.

A ground type of a triple $t=(I_s,p,I_o)$ is a triple $T=C_s*p*C_o$ that
includes the ground types of $t$'s components $I_s$ and $I_o$, and the
property $p$ which now has the role of a type. A ground type of a
triple is defined by the following rule.

\begin{equation}
\label{rul:3-ground}
\dfrac{t\in\/\T_i,\ t=(I_s,p,I_o)\quad I_s:_\darr\/C_s\quad I_o:_\darr\/C_o\quad p:_\darr\text{rdf:Property}}
      {t:_\darr\/C_s*p*C_o}
\end{equation}

The class $C_s$ is one of the ground types of $I_s$, and the type $C_o$
is one of the ground types of $I_o$. The predicates are treated
differently to the subject and object components of triples. The
predicates have the role of classes while they are instances of
rdf:Property.

There can be multiple ground types of a triple. They may be gathered
into a single $\land$-type by using the following rule. The types
$T_1$,\ldots,$T_n$ are obtained using Rule~\ref{rul:3-ground}.

\begin{equation}
\label{rul:3-ground-gather}
\dfrac{\forall\/i\in[1..n],\ t:_\darr\/T_i}
      {t:_\darr\land[T_i]}
\end{equation}


\notes{Typing using lub types of $T_1..T_n$. Explain why this is needed?}

Let us now define the least upper bound types (abbr. \emph{lub}) of
ground types derived by Rule \ref{rul:3-ground-gather}. Since a
partialy ordered set is not a lattice, we can have more than one lub
type for a given set of ground types.

The lub types of a given list of triple types $T_1..T_n$ are
computed in two steps as before when gathering multiple ground types
with conjunction. A single lub type is defined as follows.

\begin{equation}
\dfrac{t:_\darr\land[T_1..T_n]\quad T\in\T_t,\quad \forall\/i,\ T_i\preceq\/T\quad \forall\/S\in\T_t,\ \forall\/i,\ (T_i\preceq\/S\land\/T\preceq\/S)\lor\/T\not\sim\/S}
      {t:_\sqcup\/T}
\end{equation}

\begin{equation}
\dfrac{t:_\darr\land[T_1..T_n]\quad \vdasharr\/T=\sqcup[T_1..T_n]}
      {t:_{\darr\sqcup}\/T}
\end{equation}

\begin{equation}
\dfrac{t:_\darr\land[T_1..T_n]\quad \vdasharr\forall\/i\in[1..m],\ S_i=\sqcup[T_1..T_n]}
      {t:_{\darr\sqcup}\land[S_1..S_m]}
\end{equation}

The above rule states that a type $T$ is a lub type of a ground type 
$\land[T_1..T_n]$ if all ground types $T_i$ are subtypes of
$T$. Furthermore, the lub type $T$ is the least (closest) supertype of
all members of ground $\land$-type $T_1,\ldots\/,T_n$. The lub types
can be now gathered using the following rule.

\begin{equation}
\dfrac{\forall i\in[1..n](t:_\sqcup\/T_i)}
      {t:_\sqcup\land[T_1..T_n]}
\end{equation}


\memo{The types of $s$ and $o$ can be any classes $T_s$ and $T_o$ from
  ${\cal I}_c$, while the type of $p$ has to be a class $T_p$ that is
  a subclass of rdf:Property. The typing of a triple $t$ is correct
  since the interpretation of $T$ includes $t$.}

\memo{Moreover, the types $T$ that are derived by the above rule are
  minimal in the sense that given the information provided, i.e., the
  types of $t$'s components, their interpretations are minimal
  possible comparing them to the interpretations of all other derived
  types of $t$.}






\subsection{Stored types of triples}

\notes{General comments.}
\notes{Analysis tool. Show minimality of the stored types (either enumerated or gathered with $\bigvee$).}
\notes{\emph{Reminder:} when a complete stored (user-defined) type is related to the base type of a triple, some of GLB types may be eliminated.}

\notes{Present the complete story.}
\notes{Computing the minimal and valid stored type of a triple $t=(s,p,o)\in\T_i$.}
\notes{Stored types are defined by linking a predicate $p$ to a domain and range classes.}
\notes{Only types (domains and ranges) defined for $p'\succeq\/p$ are valid stored types.}
\notes{There are no other valid types below, i.e., for $p'\prec\/p$.}
\notes{Among the valid stored types the most specific and unrelated stored types are selected.}
\notes{In other words, only glb types of valid stored types are selected.}
\notes{Finally, the minimal and complete type of $t$ is an $\lor$-type including all previously selected glb types.}

We first find stored triple types for a given triple $t=(s,p,o)$. A
stored schema triple is constructed by selecting types including a
predicates $p'\succeq\/p$ that  the domain and range defined.

\begin{equation}
\label{rul:3-stored}
\dfrac{t\in\T_i,\, t=(s,p,o)\quad p'\in\I_p, p\preceq\/p'\quad (p',\text{domain},T_s)\in\/g\quad (p',\text{range},T_o)\in\/g}
      {t:_\uarr\/T_s*p*T_o}
\end{equation}


\medskip
%\notes{Generator view of rules: Just describe the properties of pre-conditions and conclusions for a particular lub type of triple.}
\notes{Comments and description of the above rule.}
\notes{Note p is used for all types. p shoud be in most specific type -}
\notes{It makes no sense to generate types with p'.} 

The domain and range of a predicate $p$ can be defined for any
super-predicate, they do not need to be defined particulary for
$p$. In addition, the domain and range of a predicates do not need to
be defined for the same predicate; they can be defined for any of the
super-predicates separately. The following rule captures also the last
statement.

\medskip
\notes{Somewhere here, the inheritance should be noted.}
\notes{Inheritance should be treated in knowledge graphs!}
\notes{Predicates inherit in the same way as the classes.}

\begin{equation}
\label{rul:3-stored1}
\dfrac{t\in\Ti, t=(s,p,o)\quad p_1,p_2\in\I_p\quad p\preceq\/p_1\quad p\preceq\/p_2\quad (p_1,\text{domain},T_s)\in\/g
                \quad (p_2,\text{range},T_o)\in\/g}
      {t:_\uarr\/T_s*p*T_o}
\end{equation}

\notes{Explanation of the rule.}
\notes{If $p$ inherits from multiple $p'\succeq\/p$, then the above rule generates multiple types. Explain.}
\notes{Note that the type is determined only if the domain and range of $p$ or some $p'\succeq\/p$ is defined.}
\notes{Otherwise, the domain and range shoud be $\top$. This should be included.}

The following rule is a judgment for a (user-defined) type of a
concrete triple $t=(s,p,o)$. A user-defined type of $t$ is the
greatest lower bound (abbr. glb) of stored types generated by the rule
\ref{rul:3-stored}.

\medskip
\notes{Valid stored types of t: the smallest valid glb types of all stored types.}
\notes{Justification: smallest interpretation - smallest search space for queries.}
\notes{Valid stored types are solely those defined "above" p.}
\notes{The glb types of valid stored types "above" p is selected!}
\notes{The rule generates one glb type by one.}
\notes{These (glb types) are collected in a $\lor$-type including all GLB types.}

\notes{The meaning of $\not\sim$ is "\emph{not related}".}
\notes{This can be either that we have two $p$ roots with unrelated glb schema triples (trees up).}
\notes{Or, two $p$-rooted but unrelated stored types through multiple inheritance.}
\notes{Therefore, we can have more than one stored GLB types.}

\begin{equation}
\dfrac{t\in\T_i\quad T\in\T_t,\, t:_\uarr\/T\quad \forall\/S\in\T_t,\, t:_\uarr\/S\quad T\preceq\/S\lor\/T_i\not\sim\/S}
      {t:_\uarr^\_\/T}
\end{equation}

The first premise says that $t$ is a ground triple. The second premise
enumerates stored types $T$ of $t$. The third premise requires that
$T$ is the most specific type of all possible types $S$ of $t$. In
other words, there is no type $S$ of $t$ that is a subtype of
$T$. Hence, $T$ is the glb type of the stored types of $t$.

The implementation view of the above rule is as follows. The schema
triples are obtained from the inherited values of the predicates
rdfs:domain and rdfs:range. The inherited values have to be the
closest when traveling from property $p$ towards the more general
properties.

The glb types are now gathered in a $\lor$-type. Hence, the resulting
$\lor$-type includes all glb types of $t$.

\begin{equation}
\dfrac{\forall\/T_i\in\T_t,\, t:_\Darr\/T_i}
      {t:_\Darr\lor[T_i]}
\end{equation}

The premise says that we identify all triple types $T_i$ that
are the individual (glb) $\sqcap$-types of $t$. 

\medskip
\notes{What is the reason that we have multiple glb types?}

Multiple different stored types of $t$ are possible only in
the case of multiple inheritance, in the case of the definition of the
disjunctive domain/range types, or if predicate is defined for
semantically different concepts.

\notes{Describe each possibility in more detail.}





\subsection{Typing a triple}

\notes{Two ways of defining semantics.}
\notes{1) enumeration style: stored types are enumerated as alternatives ($\lor$).}
\notes{2) packed together: alternative types are packed in one $\bigvee$ type.}
\notes{One advantage of (1) is that individual glb types can be processed further individually.}
\notes{Advantage of (2) is the higer-level semantics without going in implementation.}

\notes{Now stored types have to be related to all lub base types to represent the correct type of a triple.}
\notes{It seems it would be easier to check the pairs one-by-one using (1) in algorithms.}
\notes{In case of using complete types in the phases, types would further have to be processed by $\land,\lor$ rules.}

The type of a triple $t=(s,p,o)$ is computed by first deriving the
base type $T$ and the top type $S$ of $t$. Then, we check if $S$ is
reachable from $T$ through the sub-class and sub-property hierarchies,
i.e., $T\preceq\/S$.

\begin{equation}
\dfrac{t\in\T_i\quad T\in\T_t,\, t:_{\darr}T\quad S\in\T_t,\, t:_\uarr\/S\quad T\preceq\/S}
      {t:S}
\end{equation}

\medskip

\medskip
\notes{How to compute $T\preceq\/S$? Refer to position where we have a description.}
\notes{Order the possible derivations, gatherings (groupings) ... of types.}

\notes{Possible diagnoses.}
\notes{Components not related to a top type of a triple?}
\notes{Components related to sub-types of a top type?}
\notes{Above pertain to all components.}




\subsection{Typing a graph}

\notes{What is a type of a graph?}
\nnotes{A type of a graph is a graph!}
\nnotes{It includes a set of triple types forming a schema graph.}

\notes{Typing schema triples?}
\nnotes{What can be checked?}
\nnotes{Is a schema triple properly related to the super-classes and types of components.}
\nnotes{Consistency of the placement of a class in an ontology.}
\nnotes{A class or predicate component not related to other classes?}
\nnotes{A class or predicate component attached to ``conflicting'' set of classes? ?}
\nnotes{Any other examples?}

\notes{Typing a graph.}
\nnotes{Checking whether triple types match in the meeting points.}
\nnotes{What is the type in meeting points of two triple types?}
\nnotes{Since a tye of a graph should present any legal triple in $\D$}
\nnotes{}


\section{Implementation of type-checking}


\subsection{Computing LUB ground types}

\notes{A ground type of a triple $t=(s,p,o)$ is a type $(s_t,p,o_t)$ such that $(s,\text{rdf:type},s_t)$ and $(o,\text{rdf:type},o_t)$.}
\notes{The sets of types $s_t$ and $o_t$ are stored in the sets $g_s$ and $g_o$, respectively.}
\notes{The ground type of $t$ is then $T_t=(\land\/g_s,p,\land\/g_o)$.}
\notes{The lub of a type $T_t$ is computed as follows.}

\notes{For each $s_t\in\/g_s$ ($o_t\in\/g_o$) compute a closure of a set $\{s_t\}$ ($\{o_t\}$) with respect to the relationship rdfs:superClassOf obtaining the sets $c_s$ and $c_o$.}
\notes{Each step of the closure newly obtained classes are marked with the number of steps if new in the set, and the maximum of both numbers of steps otherwise.}
\notes{The maximum guaranties the monotonicity: $s_t\prec_\darr\/s_t'\Rightarrow\/m(s_t)>m(s_t')$.}
\notes{Proof: Assume $m(s_t)<=m(s_t')$. Since $s_t\prec_\darr\/s_t'$ then $m(s_t')+1$ is maximum of $s_t$. Contradiction.}

\notes{The lub of $T_t$ is computed by intersecting all sets $c_s$ ($c_o$) obtained for each $s_t$ ($o_t$), yielding a lub type of $g_s$ ($g_o$).}
\notes{The intersection of sets is computed step-by-step. Initially, intersection is the first set $c_s$ ($c_o$) of some $s_t$ ($o_t$).}
\notes{In each step, a new set $c_s$ ($c_o$) for another $s_t$ ($o_t$) is intersected with previous result.}
\notes{The classes that are in the result (intersection) are merged by selecting the maximum number of closure steps for each class in the intersection.}
\notes{The reason for this is to obtain the number of steps within which all ground classes reach a given lub class.}

\notes{Finally, the lub classes are selected from the resulted intersection of all $c_s$ ($c_o$).}
\notes{The class with the smallest number of steps is taken. Then, it is deleted from the set together with all its super-classes.}
\notes{If set is not empty the previous step is repeated.}

\subsection{Computing GLB stored types}


\notes{We have a tuple $t=(s,p,o)$.}
\notes{The task is to compute glb of $t$'s stored types.}
\notes{The algorithm is using the predicates $p'\preceq\/p$ to obtain all domains and ranges of $p$.}



\notes{FUNCTION typeGlbStored ($p$: Property, $cnt$: Integer, $d_p$,$r_p$: Set): Type}
\notes{BEGIN}
\notes{if $d_p=\{\}$ then $d_p =  \{ c_s \mid (p,\text{rdfs:Domain},c_s)\in\/G\}$}
\notes{if $r_p=\{\}$ then $r_p =  \{ c_o \mid (p,\text{rdfs:Range},c_o)\in\/G\}$}
\notes{if $d_p\not=\{\}\land\/r_p\not=\{\}$ then }
\notes{RETURN $(\lor\/d_p,p,\lor\/r_p)$}
\notes{$ts = \{\}$}
\notes{for $p'$ ($(p,\text{rdfs:SubPropertyOf},p')\in\/G$)}
\notes{BEGIN}
\notes{$T_{p'} = typeGlbStored(p',cnt+1$,$d_p$,$r_p$)}
\notes{$ts = ts\cup\/\{T_{p'}\}$}
\notes{END}
\notes{RETURN $\lor\/ts$}
\notes{END}




%\notes{Start with a set $\{p\}$ and close the set by using rdfs:superPropertyOf marking them with the ``distance'' from $p$.}
%\notes{Gather all domain and range types of $p'\preceq\/p$ in $d_p$ and $r_p$, respectively, marking each domain and range class with the distance of the related $p'$.}
%\notes{Generate types $\lor(s_t,p,o_t)$ where $s_t\in\/d_p$, $o_t\in\/r_p$ and both $s_t$ and $o_t$ are marked with the minimal values.}
%\notes{Note that there can be more than one element $s_t$ (and $o_t$) marked with a minimal value in $d_p$ (and $r_p$). Hence Cartesian product of the selected domains and ranges are used to generate types $(s_t,p,o_t)$. }



\subsection{Relating LUB ground and GLB stored types}






\section{Related work}

\notes{Comparing typing relation in an OO model with a KG \cite{Pierce2002}.}
\notes{Include the differences between Pierce's (classical) sub-typing view of stored sub-class relationships among classes and the approach taken in this paper}
\notes{Pierce treats classes as generators of objects that inherit methods and data members from its super-class.}
\notes{The methods are inherited by copying the definitions in each subclass and then explicitely calling the method in the superclass.}
\notes{List the differences: classes are identifiers, there is a sub-class relationship included in a sub-typing relationship.}






\section{Conclusions}



% \section{Acknowledgments}
%
%The authors acknowledge the financial support from the Slovenian Research Agency (research core funding No. P1-00383).

\bibliographystyle{abbrv}
\bibliography{biblio}

\end{document}



= rules for identifiers
- assumtions
. suppose we have I, a set of identifiers from g
. suppose we have a 

- type-check literals


.................before 05/27/22....................

= (task) general picture
- we have graph pattern 
. a set of triples including consts and vars
- we derive types of TPs



- we derive types of GPs


= (task) determine a type of a TP
. type of TP without a predicate? use rdf:predicate.
. type of TP without the schema? use generalizations.
. type of TP with predicate? use a triple type defined as the schema.
. type of TP can be \cup of triple types (defined in the schema).


= (task) compute a type of a GP
. meeting points in GP: use \cap type constructor
. \cap of \cup of triple types can select one of triple types
. one triple type is selected by other oper of \cap


= (task) compute the type of a concrete triple
- we need a type of a concrete triple, e.g. for distribution
. if we have schema triple than it can be utilized
. obtain the type of each constant
. schema type, or, the most specific type?
