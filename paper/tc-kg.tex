\documentclass[runningheads]{llncs}

\pdfoutput=1
\usepackage{times}
\normalfont
\usepackage{latexsym}
\usepackage[T1]{fontenc}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphics}
\usepackage{color}
\usepackage{url}

% symbols
\newcommand{\s}{\scriptscriptstyle\ \,} 
\newcommand{\ul}{\underline} 
\newcommand{\ol}{\overline} 
\newcommand{\darr}{\downarrow} 
\newcommand{\uarr}{\uparrow} 
\newcommand{\Darr}{\Downarrow} 
\newcommand{\Uarr}{\Uparrow} 
\newcommand{\llb}{\llbracket}
\newcommand{\rrb}{\rrbracket}
\newcommand{\vdasharr}{%
    \mathrel{%
        \vdash\hspace*{-5pt}%
        \raisebox{2.3pt}{\scalebox{.5}{\(\blacktriangleright\)}}%
    }%
}\newcommand{\D}{{\Delta}} 
\newcommand{\U}{{\cal U}} 
\newcommand{\B}{{\cal B}} 
\newcommand{\Lt}{{\cal L}} 
\newcommand{\St}{{\cal St}} 
\newcommand{\Pt}{{\cal Pt}} 
\newcommand{\Ot}{{\cal Ot}} 
\newcommand{\I}{{\cal I}} 
\newcommand{\Ii}{{\cal I}_i} 
\newcommand{\Ic}{{\cal I}_i} 
\newcommand{\Ip}{{\cal I}_p}
\newcommand{\V}{{\cal V}} 
\newcommand{\Vl}{{\cal V}_l} 
\newcommand{\Vi}{{\cal V}_i} 
\newcommand{\Vt}{{\cal V}_t} 
\newcommand{\Vp}{{\cal V}_p}
\newcommand{\T}{{\cal T}}
\newcommand{\Ti}{{\cal T}_i}
\newcommand{\Tt}{{\cal T}_t}
\newcommand{\cl}{\text{:}} 
\newcommand{\rdftype}{\text{rdf:type}} 
\newcommand{\rdfsubcl}{\text{rdfs:subClassOf}} 
\newcommand{\rdfsubclpl}{\text{rdfs:subClassOf+}} 
\newcommand{\rdfsubprop}{\text{rdfs:subPropertyOf}} 
\newcommand{\rdfsubproppl}{\text{rdfs:subPropertyOf+}} 
\newcommand{\rdfsdomain}{\text{rdfs:domain}} 
\newcommand{\rdfsrange}{\text{rdfs:range}} 
\newcommand{\finbox}{\phantom{.}\hfill\Box}
\newcommand{\nl}{\hfill\break}
\newcommand{\vb}[1]{\begin{small}\texttt{#1}\end{small}}
\newcommand{\lub}{l}
\newcommand{\memo}[1]{}
\newcommand{\notes}[1]{\noindent\begin{small}-- \emph{#1}\hfill\break\end{small}}
\newcommand{\nnotes}[1]{\indent\begin{small}-- \emph{#1}\hfill\break\end{small}}
\newcommand{\nnnotes}[1]{\indent\indent\begin{small}-- \emph{#1}\hfill\break\end{small}}
\newcommand{\anotes}[1]{\indent\begin{small}\phantom{-- }\emph{#1}\hfill\break\end{small}}
\newcommand{\ennotes}[1]{\indent\begin{small}-- \emph{#1}\hfill\end{small}}
 
\def\ojoin{\setbox0=\hbox{$\bowtie$}%
  \rule[-.02ex]{.25em}{.4pt}\llap{\rule[\ht0]{.25em}{.4pt}}}
\def\leftouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie}}
\def\rightouterjoin{\mathbin{\bowtie\mkern-5.8mu\ojoin}}
\def\fullouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie\mkern-5.8mu\ojoin}}

\pagestyle{headings}
\setcounter{tocdepth}{5} %show more in the toc

\begin{document}

\title{DRAFT! \\ On typing knowledge graphs}

\author{Iztok Savnik\inst{1}} 

\authorrunning{I. Savnik}

\institute{Department of computer science, \\
  Faculty of mathematics, natural sciences and information technologies, \\
  University of Primorska, Slovenia \\
  \email{iztok.savnik@upr.si}}

\maketitle

\begin{abstract}
  The problem addressed in this paper is typing a single ground
  triple~$t$ from a knowledge graph. First, the \emph{ground type} of
  $t$ is inferred bottom-up, from the stored typing of individual
  entities which are the components of $t$. The ground type is further
  minimized and then generalized to obtain a minimal upper bound (MUB)
  type. The MUB type is an appropriate starting point for exploring
  its relations to the conceptual schema of a knowledge graph. Second,
  the \emph{schema type} of $t$ is inferred from the conceptual schema
  based on the predicate of $t$. All valid schema types of $t$ are
  gathered and then minimized to obtain a schema type with a minimal
  interpretation. Finally, the minimal schema type is filtered by
  relating it to the MUB ground type via the subtype relation to
  compute the final schema type of $t$.

  \keywords{knowledge representation \and knowledge graphs \and type systems .}
\end{abstract}

% \newpage
%\tableofcontents
%\newpage

\thispagestyle{headings}
%\tableofcontents
%\newpage




\section{Introduction}

A knowledge graph (abbr.. KG) includes a data and knowledge
representation language in the form of a graph. It is the
dictionaries, such as RDF-Schema \cite{rdfschema}, which attach
meanings to the edges of a graph, turning a graph into a language for
the representation of data and knowledge. In comparison to the data
and program structures used in programming languages
\cite{Pierce2002,Hindley1997}, the conceptual schema of a KG is more
expressive: in principle, any data and program structure can be
represented as a graph. The expressive power comes from logic that
stands behind a KG, where a graph is a set of named relations, and
triples are logical statements. Let us depict some of the features of
the data and knowledge representation language of a KG.

First, a KG includes predefined classes and predicates that are
organized into taxonomies \cite{Baader2002}. Second, typing of ground
identifiers, as well as typing of the predicates with the domain and
range types, is stored in a KG. Further, similarly to the \emph{roles}
\cite{Brachman1985} of a knowledge base, the predicates of a KG are
treated as classes (types) that are included in a taxonomy of
predicates. However, they also act as individual entities described
with additional predicates. Finally, the predicates are inherited
through the taxonomy of classes, and, from the other point of view,
the domain and range types of the predicates are inherited through the
hierarchy of predicates.

Typing a knowledge graph requires a framework for the definition of
rules, which is different from the framework for classical typing of
programming languages. While typing in programming languages is based
on the syntactical composition of a program, a knowledge graph is
built from simple triples. Triples can form rich semantic structures
depending on the kinds of entities and values. The kind of object,
for example, can be either a ground value or a class. Typing of a KG
must, therefore, be able to grasp the kinds of objects in the rules,
and, in many cases, need to be guided by a procedure.

From a logic perspective, the ground entities and triples represent
an ABox, while the schema of KG is a TBox and represents logical
statements about classes and binary relations. The syntactical
structures that we use for types are the following. First, we have 
the classes and predicates, the types of identifiers, that are
identifiers themselves. Second, the type of triples is a product type,
a triple itself. Next, the $\land$ and $\lor$ types capture many
requirements of the KG domain very naturally. For instance, entities
belong to multiple classes simultaneously, or a domain of a predicate
is two different classes. Finally, the taxonomies of classes and
predicates are hard to grasp structurally; rather, posets can be
manipulated with algebraic operations.

The paper presents a study of typing a single ground triple $t$. We
propose to infer first the ground type of $t$ using the stored typing
of identifiers. The ground type is minimized and then generalized to
the minimal upper bound (MUB) type. The MUB type is an appropriate
starting point to search for the triple types from a KG conceptual
schema.

The final triple type of $t=(s,p,o)$ is selected from the triple types
provided by a conceptual schema stored in a KG. Using the predicate
$p$ as the starting point, we choose first all valid triple types
including a predicate $p$ or one of $p$'s super-predicates. The set of
selected triple types is minimized to obtain a set of minimal and
unrelated triple types, the candidates for the type of $t$.

The appropriate candidate triple types are selected by relating the
candidates to the MUB ground type by means of a subtype relation. The
disjunctively bound candidate triple types that are related to the MUB
ground type via subtype relation form the final type of~$t$.

The contributions of the presented research are as follows. First, to
our knowledge, this is the first proposal for typing a knowledge graph
that encompasses a complete KG. The existing approaches to typing a KG
deal with the particular problems of typing a KG. Second, the
presented framework for typing ground triples can serve conveniently
for the implementation of type-checking the stored typing of a KG. The
analysis of typing an individual triple spans from the ground types at
the lower levels of ontology to the minimal schema types at the upper
levels of ontology. Finally, we show that the triple types can be used
to disambiguate the sense of a predicate with multiple meanings.

The paper is organized as follows. The following Section
\ref{sec:prelim} presents some preliminary topics, including the
introduction to a knowledge graph as an RDF graph, the description of
the KG data model, and the definition of the rule language. Next,
typing of identifiers is presented in Section
\ref{sec:typ-idents}. Here we present typing literals and introduce
typing and subtyping of identifiers. In Section \ref{sec:intsc-union}
we present the semantics of $\land$-$\lor$ types, the associated rules
for typing and subtyping, and introduce the join and meet
types. Typing of triples is described in Section \ref{sec:triples}. We
present the derivation of ground and schema triple types, and the
rules to combine these two to obtain the final
type. Section~\ref{sec:related} presents an overview of the related
work on typing KGs. Finally, in Section \ref{sec:conclude} we discuss
some directions of further work.






\section{Preliminaries\label{sec:prelim}}


\subsection{Knowledge graph\label{sec:kg}}

This section defines a knowledge graph as a RDF graph \cite{rdf} using
RDF-Schema \cite{rdfschema} for the representation of the structural
part of a knowledge base. 

Let $I$ be a set of URI-s, $B$ be a set of blanks and $L$ be a set of
literals. Let us also define sets $S = I\cup\/B$, $P = I$, and
$O = I\cup\/B\cup\/L$. A \emph{RDF triple} is a triple
$(s,p,o)\in\/S\times\/P\times\/O$. A \emph{RDF graph}
$g\subseteq\/S\times\/P\times\/O$ is a set of triples. Set of all
graphs will be denoted as $G$.

The complete set of triples of a RDF graph is in the text denoted as
$\Delta$. We use $\Delta$ when we want to refer to the original set of
KG triples and not the data model of a KG presented in the following
Section.

%We say that RDF graph $g_1$ is \emph{sub-graph} of $g_2$, denoted
%$g_1 \sqsubseteq g_2$, if all triples in $g_1$ are also triples from
%$g_2$. 





\subsection{A data model of a KG}

To abstract away the details of the RDF data model we unify the
representation of knowledge graph by separating solely between the
identifiers and triples. The identifiers include the set of individual
identifiers and the set of class identifiers. The triples inlcude the
set of ground triples and the set of triple types.

%In view of the above formal representation of RDF triples, the
%complete set of identifiers is $\I=I\cup\/B\cup\/L$. The identifiers
%from $\I$ are classified into the sets including literals $\I_l$,
%individual (ground) identifiers $\I_i$, class identifiers $\I_c$,
%predicate identifiers $\I_p$.

However, since typing of a KG is based on the separation between the
values and the types, we use the following classification of
identifiers and triples. The set of values $\V$ includes the
individual identifiers $\V_i$ and the individual (ground) triples
$\V_t$. To be able to refer to the specific subsets of $\V_i$ in the
rules, we also introduce the set $\V_l\subseteq\V_i$, which denotes a
set of literal values, and the set $\V_p\subseteq\V_i$ that refers to
the set of predicates from a KG. Finally, a set $\T_p\in\T_i$ stands
for all predicates of a KG that now have the role of types. Note that
predicates are treated both as values and as types.

The set of all valid types $\T$ of a KG comprises the class
identifiers $\T_i$, i.e. types of individual identifiers $\V_i$, and
the triple types $\T_t$, i.e. the types of individual triples $\V_t$.

The set of class identifiers $\T_i$ related by subclass relation is a
poset forming a taxonomy of classes. Similarly also predicates, now
in the role of types, are ordered in a poset. The meaning of class
identifiers is established by their interpretations. The
interpretatation of a class identifier $c$ comprises the instances of
a given class $c$ es well as the instances of all $c$'s sub-classes. 

The individual triples include solely the individual identfifiers from
$\V_i$ in places of S and O, and predicates $\V_p$ in the place of P
component of a triple. The types of individual triples are product
types $S*p*O$ where $S,O\in\T_i$ and $p\in\T_p$. The product types are
in our data model of a KG written as a triple $(S,p,O)$. The triple
types are ordered by a subtype relation to form a poset. The subtype
relation among the triple types is defined on the basis of the subtype
relation among the classes and predicates. A more detailed formal
definition of a KG is given in \cite{Savnik2025}.





\subsection{Typing rule language}

\memo{
In this paper we define typing of a data language used to represent an
ABOX \cite{Brachman2004KnowledgeRR} of a knowledge base given in a
form of a knowledge graph. The data language specifys the assertions
in the form of ground triples (ABOX) and the schema of assertions as
the types of triples (TBOX). The ground triples are the instances of
the triple types that altogether define the schema of a KG.}

We do not use standard typing rule language
\cite{Pierce2002,Hindley1997} that includes a context $\Gamma$ where
the types of the variables are stored. We use a meta-language that is
rooted in first-order logic (abbr., FOL) but similar to the one used
by Pierce in \cite{Pierce2002}, in particular, for the representation
of records and subtyping, as well as for the definition of the
universal quantification.

The rules are composed of a set of premises and a conclusion. The
premises can be expressions stating the set membership of an object,
typing and subtyping judgements, or expressions in the FOL including
the previous two forms. The expressions of FOL can express complex
premises such as, for example, the conditions for the LUB types. The
conclusion part of the rule is a typing or subtyping judgment.

The symbols used in a rule are grounded by stating their membership in
the sets of identifiers ($\V$, $\V_i$ and $\V_t$) and triples ($\T$,
$\T_i$ and $\T_t$) defined in Section \ref{sec:kg}. When we write
$O\in\/S$ then we mean the \emph{existence} of $O$ in a set $S$. We
use universal quantification $\forall\/O\in\/S,\ p(O)$ when we state
that some property $p(O)$ holds for all objects $O$ from $S$. The
premises of the rule are treated from the left to the right. The
quantification of the symbols binds the symbols up to the last premise
unless defined differently by the parentheses.

\memo{
Similar to \cite{Dunfield2021}, we differ between two interpretations
of rules. First, the \emph{generator} view of rules is the forward
interpretation where rules infer the types from the types derived by
premises. Second, the \emph{type-checking} view of the rules is the
backward interpretation. Given the expression and its type, the rules
are applied backwards to verify that the expression has that type.}
In this section we present the basic typing of individual (ground)
identifiers $\V_i$. Typing of literals $\V_l$ is described in Section
\ref{sec:literals}. Nest, the rules for typing ground identifiers are
presented in Section \ref{sec:idents-ground}. Section
\ref{sec:idents-typing} further extends ground typing and subtyping to
the complete poset set of individual identifiers $\T_i$. Finally, The
sub-typing relation $\preceq$ is defined and the types of individual
identifiers are presented. The rules for typing individual identifiers
are further used for typing individual triples $\V_t$ in Section
\ref{sec:triples}.





\section{Typing identifiers\label{sec:typ-idents}}

In this section, we present the basic typing of an individual (ground)
identifiers $\V_i$. Typing of literals $\V_l$ is described in Section
\ref{sec:literals}. Next, the rules for typing ground identifiers are
presented in Section \ref{sec:idents-stored}. Section
\ref{sec:idents-typing} further extends ground typing and subtyping to
the complete poset set of individual identifiers $\T_i$. The
sub-typing relation $\preceq$ is defined, and typing rules for the
individual identifiers are presented. The rules for typing individual
identifiers are further used for typing individual triples $\V_t$ in
Section \ref{sec:triples}.





\subsection{Typing literals\label{sec:literals}}
% check-gramm

Literal values $\V_l\subseteq\V_i$ are the instances of literal types
$\T_l\subseteq\T_i$. The literal types $\T_l$ are provided by the
RDF-Schema dictionary \cite{rdfschema}. RDF-Schema defines a rich set
of literal types, such as xsd:integer, xsd:string, or xsd:boolean.

The literals are composed of literal values and literal types. For
example, the literal
"365"\textasciicircum\textasciicircum\/xsd:integer includes the
literal value "365" and a type xsd:integer. Typing of literals is
defined by the following rule.

\begin{equation}
\dfrac{L\in\V_l\quad T\in\T_l\quad \text{"L"\textasciicircum\textasciicircum\/T}\in\Delta}
      {L:T}  
\end{equation}

The rule states that a literal value $L$ is of a type $T$ if a literal
"L"\textasciicircum\textasciicircum\/T is an element of a KG
$\Delta$. A literal type $T$ is referencing a type from the RDF-Schema
dictionary.






\subsection{Ground typing and subtyping of identifiers\label{sec:idents-stored}}
% check-gramm

The typing expression $V:_\darr\/T$ is a \emph{ground typing} relation
$:_\darr$ that links a value $V\in\V$ to a ground type $T\in\T$. The
ground typing relation is a one-step typing relation based on typing
stored in a KG.

In this section, we deal with the identifiers $I\in\V_i$, which are the
values of type $T\in\T_i$. The ground types are directly linked to the
ground identifiers via a stored typing relation in the form
$(I,\text{rdf:type},T)\in\Delta$. The expression $I:_\darr\/T$ states that a
class identifier $T$ is a ground type of an individual identifier $I$.

The subtyping expression $T_1\preceq_\darr\/T_2$ defines a subtype
relationship between the types $T_1$ and $T_2$. In the case we deal
with the identifiers, the relation $T_1\preceq_\darr\/T_2$ denotes the
subclass relations since $T_1,T_2\in\T_i$. The relation $\preceq_\darr$ is
a one-step relation that is stored in $\Delta$. Note that a unique
notation for ground typing allows us to address differently the
\emph{stored} and the \emph{derived} types of a KG.

The rule for the one-step typing relation $:_\darr$ is defined using the
predicate rdf:type.

\begin{equation}
\label{rul:ident-1step-type}
\dfrac{I\in\V_i\quad T\in\T_i\quad (I,\text{rdf:type},T)\in\D}
      {I :_\darr T}
\end{equation}

The individual entity $I$ can have more than one stored type. By
using Rule \ref{rul:ident-1step-type} as a generator, it synthesizes
all types $T_j^{j\in[1,n]}$ such that $I:_\darr\/T_j^{j\in[1,n]}$.

If we want to obtain all valid ground types of $I$, the rule can be
used either in some other rule that employs it as a generator, or we
can update the above rule to generate a $\land$-type, including all
the types of $I$ as presented in Section \ref{sec:intsc-union}.

The one-step subtyping relationship $\preceq_\darr$ is defined on
classes by using the RDF predicate rdfs:sub\-ClassOf as follows.

\begin{equation}
\label{rul:ident-1step-subtype}
\dfrac{C_1,C_2\in\T_i \quad (C_1,\text{rdfs:subClassOf},C_2)\in\D}
{C_1 \preceq_\darr\/C_2}
\end{equation}

The rule for the definition of the one-step subtyping relationship
$\preceq_\darr$ is based on the predicate rdfs:subPropertyOf.

\begin{equation}
\dfrac{P_1,P_2\in\T_p \quad (P_1,\text{rdfs:subPropertyOf},P_2)\in\D}
      {P_1\preceq_\darr\/P_2}
\end{equation}

The predicates have in the above rule the role of types in the sense
that they represent the names of the binary relations. 



\subsection{Typing and subtyping identifiers\label{sec:idents-typing}}
% check-gramm

The one-step relationship $\preceq_\darr$ is extended with the
reflectivity, transitivity, and antisymmetry to obtain the subtyping
relationship $\preceq$. The relation $\preceq$ forms a partial
ordering of individual identifiers.

The ground typing relation $:_\darr$ is then extended with the
\emph{rule of subsumption} presented as Rule
\ref{rul:typing-subsumption} to obtain a typing relation $:$. The
rules are defined for the set of types $\T$ that includes the types of
individual identifiers $\T_i$ and triple types $\T_t$.

First, the one-step relationship $\preceq_\darr$ is generalized to the
relationship $\preceq$ defined over the type identifiers
$\T_i$. 

\begin{equation}
\label{rul:Ic-extended}
\dfrac{I_1,I_2\in\T_i \quad I_1\preceq_\darr\/I_2}
      {I_1 \preceq I_2}
\end{equation}

Next, the subtyping relationship $\preceq$ is reflexive.

\begin{equation}
\label{rul:Ti-reflexivity}
\dfrac{I\in\T_i}
      {I\preceq\/I}
\end{equation}

The subtype relationship is also transitive. 

\begin{equation}
\label{rul:Ti-transitivity}
\dfrac{I_1,I_2,I_3\in\T_i\quad\/I_1\preceq\/I_2\quad\/I_2\preceq\/I_3}
      {I_1\preceq\/I_3}   
\end{equation}

Finally, the subtype relationship is antisymmetric, which is expressed
using the following rule.

\begin{equation}
\label{rul:Ti-antisymmetry}
\dfrac{I_1,I_2\in\T_i \quad I_1\preceq\/I_2 \quad I_2\preceq\/I_1}
      {I_1=I_2}   
\end{equation}

As a consequence of the rules
\ref{rul:Ti-reflexivity}-\ref{rul:Ti-antisymmetry} the relation
$\preceq$ defines a poset $(\T_i,\preceq)$.

Knowledge graphs include a special class $\top$ that represents the
root class of the ontology. In RDF ontologies, $\top$ is usually
represented by the predicate owl:Thing \cite{Hoffart2013}. The
following rule specifies that all class identifiers are more specific
than $\top$.

\begin{equation}
\dfrac{\forall\/S\in\T_i}
      {S\preceq\top}
\end{equation}

%\subsection{Typing of identifiers.}
The one-step typing relation $:_\darr$ is now extended to the typing
relation $:$ that takes into account the subtyping relation $\preceq$.
The following rule states that a stored type is a type.

\begin{equation}
\dfrac{I\in\V_i\quad\/C\in\T_i\quad\/I:_\darr\/C}
      {I:C}
\end{equation}

The link between the typing relation and the subtype relation is
provided by adding a typing rule called \emph{rule of subsumption}
\cite{Pierce2002}.

\begin{equation}
\label{rul:typing-subsumption}
\dfrac{I\in\T_i\quad\/S,T\in\T_i\quad\/I:S\quad\/S\preceq\/T}
      {I:T}    
\end{equation}








\section{Intersection and union types\label{sec:intsc-union}}
% check-gramm

The rules for the $\land$ and $\lor$-types presented in this section
are general---they apply for the identifier types $\T_i$ and triple
types $\T_t$.

The meaning of the $\land$ and $\lor$-types can be seen through
their interpretations. The instances of the intersection type
$T_1\land\/T_2$ are objects belonging to both $T_1$ and $T_2$. The
type $T_1\land\/T_2$ is the greatest lower bound of the types $T_1$
and $T_2$. In general, $\land_{i=1}^n\/T_i$ is the greatest lower
bound (abbr. GLB) of types $T_i^{\s\/i=1..n}$
\cite{Pierce1991,Pierce1996}. The instances of the type
$\land_{i=1}^n\/T_i$ form a maximal set of objects that belong to
all types $T_i$.

The union type is dual to the intersection type. The instances of
the union type $T_1\lor\/T_2$ are objects from the interpretations of
both types, $T_1$ and $T_2$. The type $T_1\lor\/T_2$ denotes the least
upper bound of types $T_1$ and $T_2$. A general form of union type is
$\lor_{i=1}^n\/T_i$. The interpretation of $\lor_{i=1}^n\/T_i$
represent the minimal set of instances that include the instances of
all types $T_i^{\s\/i=1..n}$.

The interpretation of a type $\land_{i=1}^n\/T_i$ is included in
interpretation of every particular type $T_i$ which means
$\land_{i=1}^n\/T_i\preceq\/T_i$. This is stated by the following
rule.

\begin{equation}
\label{rul:land-preceq-elems}
\dfrac{T_i^{\s\/i=1..n}\in\T}
      {\land_{i=1}^n\/T_i\preceq\/T_i^{\s\/i=1..n}} 
\end{equation}

Further, the following rule states that if the type $S$ is a subtype
of every type $T_i^{\s\/i=1..n}$ then $S$ is a subtype of
$\land_{i=1}^n\/T_i$.

\begin{equation}
\label{rul:lbound-preceq-land}
\dfrac{S\in\T\quad\/T_i^{\s\/i=1..n}\in\T\quad\/S\preceq\/T_i^{\s\/i=1..n}}
      {S\preceq\land_{i=1}^n\/T_i}  
\end{equation} 

The opposite to the above rule, the following rule states the
necessary conditions that must be met so that a type $T$ is a
supertype of a type $\land_{i=1}^n\/T_i$. It is enough that there is
one type $S_i\preceq\/T$ for the intersection of $S_i^{\s\/i=1..n}$ to
be included in $T$.

\begin{equation}
\label{rul:land-preceq-ubound}
\dfrac{T\in\T\quad\/S_i^{\s\/i=1..n}\in\T\quad\/S\in\{S_i\}_{i=1}^n\quad\/S\preceq\/T}
      {\land_{i=1}^n\/S_i\preceq\/T}  
\end{equation} 

The duality of the intersection and union types can also be seen from
the duality of the rules for the $\land$ and $\lor$-types.

The union type $\lor_{i=1}^n\/T_i$ is the least upper bound of
types $T_i^{\s\/i=1..n}$ \cite{Pierce1991}. This means that all types
$T_i^{\s\/i=1..n}$ are subtypes of their union. 

\begin{equation}
\label{rul:lor-preceq-elems}
\dfrac{T_i^{\s\/i=1..n}\in\T}
      {T_i^{\s\/i=1..n}\preceq\lor_{i=1}^n\/T_i}
\end{equation}

The following rule defines the necessary conditions to be met for a
type $T$ to be a supertype of a type $\lor_{i=1}^n\/S_i$.

\begin{equation}
\label{rul:lor-preceq-ubound}
\dfrac{T\in\T\quad\/S_i^{\s\/i=1..n}\in\T\quad\/S_i^{\s\/i=1..n}\preceq\/T}
      {\lor_{i=1}^n\/S_i\preceq\/T}  
\end{equation}

Again, the opposite rule defines the premises that must hold so that
$T$ is a subtype of a type $\lor_{i=1}^n\/S_i$.

\begin{equation}
\label{rul:lbound-preceq-lor}
\dfrac{T\in\T\quad\/S_i^{\s\/i=1..n}\in\T\quad\/S\in\{S_i\}_{i=1}^n\quad\/T\preceq\/S}
      {T\preceq\lor_{i=1}^n\/S_i}  
\end{equation}

Note that besides checking the subtype relation between a type treated
as a whole and some logical type, Rules
\ref{rul:land-preceq-elems}-\ref{rul:lbound-preceq-lor} can be used to
check the subtyping among arbitrary logical types.






\subsection{The join and meet types\label{sec:join-meet-types}}

The $\lor$ and $\land$ types are logical types defined on the basis of
their interpretations, i.e., the sets of instances. Given two types
$T$ and $S$ we have a least upper bound $S\lor\/T$, and a greatest
lower bound $S\land\/T$ types where $S\lor\/T$ denotes a minimal set
of objects that are of type $S$ \emph{or} $T$ (or both), and
$S\land\/T$ denotes a maximal set of objects that are of type $S$
\emph{and} $T$.

A KG includes a stored poset of classes and triple types that
represent types of the individual identifiers and ground triples. The
poset can be used to compute a join $S\sqcup\/T$ and a meet
$S\sqcap\/T$ of the parameter types. Usual definition of the join and
meet operators is by using a least upper bound and a greatest lower
bound if they exist \cite{Pierce2002}, respectively. However, in a KG
we are also interested in the upper bound and lower bound types
\cite{DaveyPriestley2002}. Let us present an example.

\begin{example}
  Let $P=(U,\preceq)$ be a partialy oredered set $P$ such that
  $U=\{a,b,c,d,e\}$ and the relation
  $\preceq=\{a\preceq\/c,a\preceq\/d,b\preceq\/c,b\preceq\/d,c\preceq\/e,d\preceq\/e\}$.
  The upper bounds of $S=\{a,b\}$ are the elements $c$ and $d$. Since
  there is no lower upper bounds, the upper bounds $\{c,d\}$ are
  minimal upper bounds. The least upper bound of $S$ is $e$.

  In the case that we remove the element $e$ from $P$ then $P$ does
  not have a least upper bound but it still has two minimal upper
  bounds $c$ and $d$. $\finbox$
\end{example}

The least upper bound (abbr., LUB) is by definition one element. It has
to be related to all upper bounds via the relationship $\preceq$. On
the other hand, the most interesting upper and lower bounds are
minimal upper bounds (abbr., MUB) and maximal lower bounds (abbr. MLB)
\cite{Knudstorp2024}. They can be lower than the least upper bound and
higher than the greatest lower bound, respectively. They represent
more detailed information about the parameter set of types $S$ than
the LUB type of $S$.

The join $J=\sqcup_{i=1}^n\/T_i$ is a set of MUB types
$J_j^{j\in[1,m]}\in\/J$ such that $J_j$ is an upper bound with
$T_i^{\s\/i=1..n}\preceq\/J_j$, and there is no such $L$ where
$T_i^{\s\/i=1..n}\preceq\/L$ without also having $J_j\preceq\/L$. Since
we have a top type $\top$ defined in a KG, the join of arbitrary two
types always exists.

The meet of types $T_i^{\s\/i=1..n}]$, $M=\sqcap_{i=1}^n\/T_i]$, is
a set of the maximal lower bound types $M_j^{j\in[1,m]}\in\/M$ such
that $M_j$ is lower bound with $M_j\preceq\/T_i^{\s\/i=1..n}$, and all
other lower bounds $U$ with $U\preceq\/T_i^{\s\/i=1..n}$ entail
$U\preceq\/M_j$. Note that the meet of the set of types from a KG does
not always exist.

The join type is related to the $\lor$-type. Given a set of types
$\{T_i\}_{i=1}^n$, the join $J=\sqcup_{i=1}^n\/T_i$ is a set of types
$J_j^{j\in[1,m]}\in\/J$ that are the minimal upper bounds such that
$T_i^{\s\/i=1..n}\preceq\/J_j$. On the other hand, Rule
\ref{rul:lor-preceq-elems} for the $\lor$-types states
$T_i^{\s\/i=1..n}\preceq\lor_{i=1}^n\/T_i]$. However, the join type and $\lor$-type
differ in the interpretation.
$$\llb\lor_{i=1}^n\/T_i\rrb_\D=\bigcup_{i=1}^n\llb\/T_i\rrb_\D\subseteq\bigcup_{j=1}^m\llb\/J_j\rrb_\D=\llb\sqcup_{i=1}^n\/T_i\rrb_\D$$

While the interpretation of the type $\lor_{i=1}^nT_i]$ includes
precisely the instances of all $T_i$, the interpretation of the type
$\sqcup_{i=1}^n\/T_i$ contains the instances of minimal upper bound
types. The interpretation of $\sqcup_{i=1}^n\/T_i$ can include
interpretations of classes that are not among $T_i^{\s\/i=1..n}$.

A meet type of $T_i^{\s\/i=1..n}$ may not exist in a poset of types
from a KG. In general, the meet types $M=\sqcap_{i=1}^n\/T_i$
exist in a class ontology if the types $T_i^{\s\/i=1..n}$ are
\emph{bounded below} \cite{Pierce2002} which means that there exists a
type $L$ such that $L\preceq\/T_i$ for all $i$. The meet types are not
frequent on the lower levels of a class ontology from a KG.

As in the case of the $\lor$-type and the join type, the semantics of
the $\land$-type is similar to the semantics of the meet type. An
$\land$-type is a type that implements logical view of the greatest
lower bound type. Differently, the meet types are based on the
concrete poset of KG types and represent concrete types though their
interpretation is contained in the interpretation of a
$\land$-type. The type $\land_{i=1}^n\/T_i$ denotes the intersection
$\bigcap\/\llb\/T_i\rrb_\D$ while the interpretation of a meet types
$M_j^{\s\/j=1..m}\in\sqcap_{i=1}^n\/T_i$ includes the union
$\cup_{j\in[1,m]}\llb\/M_j\rrb_\D$. Since
$M_j\preceq\/T_i^{\s\/i=1..n}$, then
$\llb\/M_j\rrb_\D\subseteq\llb\/T_i^{\s\/i=1..n}\rrb_\D$. Hence,
$\llb\sqcap[T_i^{\s\/i=1..n}]\rrb_\D=\cup_{j=1}^m\llb\/M_j\rrb_\D$

Note that the instances of the meet types
are in the intersection of the instances of types
$T_i^{\s\/i=1..n}$. The set $\bigcap\/\llb\/T_i\rrb_\D$ can also
include objects that are not instances of any meet type from
$M$. Hence,
$$\llb\land_{i=1}^n\/T_i\rrb_\D=\bigcap_{i=1}^n\llb\/T_i\rrb_\D\supseteq\bigcup_{j=1}^m\llb\/M_j\rrb_\D=\llb\sqcap_{i=1}^n\/T_i\rrb_\D.$$

In type-checking the ground triples, the join types are used in the
procedure for checking the types derived bottom-up against the stored
schema of a KG as presented in Section \ref{sec:3-ground-types}. The
join as well as meet types are useful in the procedure for
type-checking basic graph patterns \cite{Savnik2025a}. The $\lor$ and
$\land$-types are logical types that can be simplified in the typing
positions of a graph pattern by using typing rules, and can be
approximated by using join and meet types to obtain a more precise
concrete type of a graph pattern variable.




\subsection{Typing identifiers with $\land$ and $\lor$-types}

The $\land$ and $\lor$-types can model the available choices in
selection of the domain and range types of a triple type. The choices
depend on the selected model (e.g., RDF-Schema). As usual for the
expressions including a variant of $\cup$ and $\cap$ operators more
complex expressions can be transformed by moving $\cup$ and $\cap$
either inside expression or towards the outside of an expression. We
define the rules for these transformations only if they are needed for
typing ground triples.

We start with a rule for gathering the ground types of a ground
identifier $I\in\V_i$. The ground types are gathered in the premise of
the rule by selecting individual ground types as presented in Section
\ref{sec:idents-stored}.

\begin{equation}
\label{rul:land-1}
\dfrac{I\in\V_i\quad\/T_i^{\s\/i=1..n}\in\T_i\quad\/I:_{\darr}T_i^{\s\/i=1..n}}
      {I:_{\darr}\land_{i=1}^n\/T_i}
\end{equation}

%-----------------------------------------------------------------
\memo{
Let's have a look at $\land$-type composed of $I$'s ground types
$T_i^{\s\/i=1..n}$ in the case $I\in\V_i$. In Yago \cite{Hoffart2013},
often $I$ has a set of very specific classes $T_s$ but also some
general classes $C_g$. The general classes $C_g$ are close to the
classes used in the schema triple types. If stored typing of $V$ is
correct, then $C_g$ includes the classes that are supertypes of
classes from $C_s$.}
%-----------------------------------------------------------------

The ground type $\land_{i=1}^nT_i$ can include pairs of types
$T_i\preceq\/T_k$ with $i\not=k$. Depending on the further use, we can
either compute the minimal or the maximal elements from the poset
$\{T_i\}_{i=1}^n$  with respect to $\preceq$
\cite{DaveyPriestley2002}. The supertypes of the minimal elements of
$\{T_i\}_{i=1}^n$ include all valid types of $I$. Hence, we use
the set of minimal elements from $\{T_i\}_{i=1}^n$ as the starting
point to explore the relations between the ground types and the
schema types of a triple $t$.

Given a poset of types $(\{T_i\}_{i=1}^n,\preceq)$ the operator MIN
retains types $S_j^{\s\/j=1..m}\in\{T_i\}_{i=1}^n$ such that
${\nexists}\/T_i^{\s\/i=1..n}(T_k\prec\/S_j)$. All pairs of types
$S_k,S_l\in\{S_j\}_{j=1}^m$ with $k\not=l$ are \emph{incomparable},
i.e.,
$S_k\not\sim\/S_l\equiv\/S_k\not\preceq\/S_l\land\/S_k\not\succeq\/S_l$.
The logical rule for deriving minimal type from $\{T_i\}_{i=1}^n$ is
as follows.

\begin{equation}
\label{rul:min}
\dfrac{I\in\V_i\quad\/I:_\darr\land_{i=1}^n\/T_i}
      {I:_{\Darr}\land \{S \mid S\in\/\{T_i\}_{i=1}^n\quad\forall\/i\in[1,n],\ S\preceq\/T_i\lor\/S\not\sim\/T_i\}}
\end{equation}

The rule says that the types $S$ gathered with the $\land$-type are
minimal types of a ground type $\land_{i=1}^n\/T_i$. A particular type
$S$ is minimal since all other $T_i$ types are either more general or
equal ($\succeq$), or not related to $S$. 


\memo{
\begin{equation}
\label{rul:min-gather}
\dfrac{I\in\V_i\quad\forall\/i=1..m,\ I:_\Darr\/S_i}
      {V:_{\Darr}\land_{j=1}^m\/S_j}
    \end{equation}}
  

Let us now present the typing rules that, given $I\in\V_i$, determine
the join of types from $\{T_i\}_{i=1}^n$ as
$I:\sqcup_{i=1}^n\/T_i$. Recall from Section \ref{sec:join-meet-types}
that we defined the operation join as the minimal upper bound of a set
$\{T_i\}_{i=1}^n$. A join $\sqcup_{i=1}^n\/T_i$ is a set of
minimal upper bounds $\{S_j\}_{j=1}^m$ that are related to all
types $T_i^{\s/i\in[1,n]}$ via $\preceq$, and are minimal.

\begin{equation}
\label{rul:join-logic}
\dfrac{I\in\V_i,\, \/I:_\darr\land_{i=1}^n\/T_i}
      {I:_\sqcup\land\{S \mid \/S\in\T_i,\,\/T_i^{\s\/i=1..n}\preceq\/S\land\forall\/P\in\T_i,\,(T_i^{\s\/i=1..n}\preceq\/P\land\/S\preceq\/P)\lor\/P\not\sim\/S\}}
\end{equation}

\memo{
The individual MUB types derived by the above rule are gathered
into one $\land$ type of MUB types by using the following rule.

\begin{equation}
\label{rul:join-gather}
\dfrac{I\in\V_i\quad\/S_i^{\s\/i=1..m}\in\T_i\quad\forall\/i=1..m,\, I:_\sqcup\/S_i}
{I:_{\sqcup}\land_{i=1}^m\/S_i}
\end{equation}}

%OUT?
The MUB types are used as the starting points for searching a correct
schema type. In case the predicate has two different definitions in
two different contextes, then the paths from a MUB type to the schema
of a KG determine the correct schema type. The details are presented
in Section \ref{sec:stored-3types}.






\section{Typing triples\label{sec:triples}}


%\subsection{Triple types\label{sec:3-types}}

A type of a triple $(s,p,o)\in\V_t$ is a product type $D*p*R$
where $s:D$ and $o:R$ holds. In our model, the triple types are
represented by a triple $(D,p,R)\in\T_t$. The types $D$ and $R$ are
type expressions that represent either a class identifier or an 
expression composed of classes related by $\land$ and/or $\lor$
operators. The available logical operators depend on the schema
languege of a KG. For now, we assume the schema language is
RDF-Schema.

The $\land$-types reflect the semantics of RDF-Schema \cite{rdfschema}
which permits the definition of multiple domains and ranges of the
predicate $p$ that are linked with $\land$-types. Consequently, each
predicate $p$ has exactly one triple type of the form
$$(\land_{i=1}^n\/D_i^{\s\/i=1..n}, p ,\land_{j=1}^m\/R_j).$$

\begin{example}
  If $p$ has two domains $D_1$ and $D_2$, and a single
range type $R$ then the type corresponding to $p$ is
$(D_1\land\/D_2,p,R)$. $\finbox$
\end{example}

\noindent
The interpretation of a triple type $(D,p,R)$ is defined as
follows.
$$\llb(D,p,R)\rrb_\Delta=\{(s,p,o)\mid\/s\in\llb\/D\rrb_\Delta\land\/o\in\llb\/R\rrb_\Delta \}$$

The subtype relationship among the triple types is defined on the
basis of the subtype relationship among classes, $\land$ and
$\lor$-types, and predicates. The following rule defines the
relationship $\preceq$ beween two triple types.

\begin{equation}
\label{rul:3-subtype}
\dfrac{T_1\in\T_t,\ T_1=(D_1,p_1,R_1)\quad T_2\in\T_t,\ T_2=(D_2,p_2,R_2)\quad\/D_1\preceq\/D_2\quad\/p_1\preceq\/p_2\quad\/R_1\preceq\/R_2}
      {T_1\preceq\/T_2}
\end{equation}

\noindent
The above Rule \ref{rul:3-subtype} handles the $\land$-types of the
subject and object through Rules
\ref{rul:land-preceq-elems}-\ref{rul:land-preceq-ubound}.







\subsection{Ground types of a triple\label{sec:3-ground-types}}
% checked

\noindent
The ground types of a triple $t$ are either a stored ground type, a
minimal ground type, or a join ground type. The stored ground type
includes types that are stored in a KG. The minimal ground type then
consists solely of the minimal types from the stored ground
types. Finally, the join ground type is the conjunction of minimal
upper bound types obtained by applying MUB operator to the conjunction
of minimal ground types \cite{Knudstorp2024}.
 
A ground type of an individual identifier $I$ is a class $T$ related
to $I$ by one-step type relationship $:_\darr$, as presented by Rule
\ref{rul:ident-1step-type}. In terms of the concepts of a knowledge
graph, $T$ and $I$ are related by the relationship rdf:type.

A ground type of a triple $t=(I_s,p,I_o)$ is a product type
$T*p*S$ that we represent as a triple $(T,p,S)$. A triple type
includes the ground types of $t$'s components $I_s$ and $I_o$, and the
property $p$, which now has the role of a type. A ground type of a
triple is defined by the following rule.

\begin{equation}
\label{rul:3-ground}
\dfrac{t\in\V_t,\ t=(I_s,p,I_o)\quad T,S\in\T_i\quad I_s:_\darr\/T\quad I_o:_\darr\/S\quad p:_\darr\text{rdf:Property}}
      {t:_\darr(T,p,S)}
\end{equation}

The type $T$ is either a class identifier or a $\land$-type composed
of a conjunction of class identifiers. The predicates are treated
differently from the subject and object components of triples. The
predicates have the role of types while they are instances of
rdf:Property.

The minimal ground type of a triple $t$ can be obtained by using the
minimal ground types of the triple components. 

\begin{equation}
\label{rul:3-min-ground}
\dfrac{t\in\V_t,\, t=(I_s,p,I_o)\quad T,S\in\T_i\quad I_s:_\Darr\/T\quad I_o:_\Darr\/S\quad p:_\darr\text{rdf:Property}}
      {t:_\darr\/(T,p,S)}
\end{equation}

The component types $T$ and $S$ of the minimal ground type
$(T,p,S)$ can represent $\land$-types. The following rule transforms
a triple type including $\land$-types into a $\land$-type of simple
triple types composed of class identifiers in place of $S$ and $O$
components. The rule is expressed in a general form by using the
typing relation "$:$", which can be replaced by any labeled typing
relation.

\begin{equation}
\label{rul:3-land-transform}
\dfrac{t\in\V_t\quad t:(\land_{i=1}^n\/S_i,p,\land_{j=1}^mR_j)}
      {t:\bigwedge_{i=1..n, j=1..m}(S_i,p,R_j)}
\end{equation}

The type in the conclusion of the rule is constructed by the Cartesian
product of the sets of types belonging to types of $S$ and $O$
components. Since each of the types $S_i$ and $R_j$ is valid for the
components $S$ and $O$, respectively, then also the triple types from
the conclusion of the rule are valid.

The above decomposition of a triple type into a set of triple types is
useful when we check the ground types against the schema triple types
to select the valid schema triple type of a triple. This is detailed in
Section \ref{sec:stored-3types}.

Finally, the join of a set of ground types is a set of minimal upper
bound types. Similarly to the previous two rules, the join is defined
on the basis of joins of triple type components $S$ and $O$.

\begin{equation}
\label{rul:3-join}
\dfrac{t\in\V_t,\ t=(I_s,p,I_o)\quad T,S\in\T_i\quad I_s:_\sqcup\/T\quad I_o:_\sqcup\/S\quad p:_\darr\text{rdf:Property}}
      {t:_\darr\/(T,p,S)}
\end{equation}

The join type $(T,p,S)$ includes in the components $S$ and $O$ the
$\land$-types comprising one or multiple MUB classes. When we convert
this type into a conjunction of single MUB triple types, then each MUB
triple type stands for all ground triple types of~$t$.

We can easily see that each particular triple type is an MUB type
since it includes MUB types in its components. Since the MUB types of
the components are incomparable by $\preceq$ then also the MUB triple
types obtained by Rule \ref{rul:3-join} are incomparable.

All rules defined for the ground triple types rely on inferring the
types of their components. The reason for this are the stored typing
of individual identifiers as well as the stored poset relation
$\preceq$, which are solely defined on classes.






\subsection{Schema triple types\label{sec:stored-3types}}
% checked L

The schema types are types of triples defined by a variant of KG
schema. The schema definition language currently used in KGs is either
RDF-Schema \cite{rdfschema} or RDF-Schema combined with OWL
\cite{owl2} vocabulary. In this section, we present the semantics of
both approaches.

We do not expect that the domain and range of the predicate are defined
for each particular predicate $p$. They can be inherited from the
super-predicates of $p$. Hence, a predicate $p$ has the domain and
range defined either directly, when domain and range are defined for
the predicate $p$, or indirectly, if the domain and range are defined
for $p$'s super-predicates and inherited by the predicate $p$.

The rules for the derivation of the schema triple type of a given
triple $t$ are presented for two different schema definition
languages. In Section \ref{sec:stored-3types}.1 we present the
derivation of schema types when the RDF-Schema is used. Further, in
Section \ref{sec:stored-3types}.2 we define the typing rules for
KGs that use RDF-Schema together with $\land$ and $\lor$ types.






\subsubsection{\ref{sec:stored-3types}.1 KGs with RDF-Schema.}
When the semantics of a KG is defined by using RDF-Schema, we can
specify one or more domain and range types, but no alternative
types. The semantics of RDF-Schema \cite{rdfsemantics} interprets
multiple domains and ranges with $\land$-type. If $p$ has two domains
$T_1$ and $T_2$ then $p$ can link subjects $I$ that are of type $T_1$
\emph{and} $T_2$. The domain type of $p$ is then $T_1\land\/T_2$, or,
in terms of OWL \cite{owl}, owl:intersectionOf$(T_1\ T_2)$. The
RDF-Schema does not allow the definition of the domain or range of a
predicate with the $\lor$-type. Consequently, each predicate can have
only one meaning.

We first determine \emph{all} valid schema types for a given triple
$t=(s,p,o)$. A schema triple type comprises a predicate $p$ and the
domain and range types linked to predicates $p'\succeq\/p$. The domain
and range types can be defined for the predicate $p$ and/or inherited
from the predicates $p'\succ\/p$. In addition, the domain and range
types can be, in general, inherited from two different
super-predicates of $p$.

\begin{equation}
\label{rul:3-stored1}
\dfrac{\begin{array}{c}
       t\in\V_i,\, t=(s,p,o)\quad p_1,p_2\in\T_p,\, p\preceq\/p_1\preceq\/p_2\quad \\
       T_i^{\s\/i=1..n}\in\T,\, (p_1,\text{domain},T_i)\in\/\Delta\quad S_j^{\s\/j=1..m}\in\T,\, (p_2,\text{range},S_j)\in\Delta
       \end{array}}
      {t:_\uarr\/(\bigwedge_{i=1}^n\/T_i, p, \bigwedge_{j=1}^m\/S_j)}
\end{equation}

The above rule generates pairs of types of the domain and range of a
predicate $p$. We allow that a domain and range types are defined for
different predicates $p_1,p_2\preceq\/p$ since such a situation can
appear in a KG. However, we have to be careful that the rules of
inheritance are respected. We can only inherit from $p_1$ and $p_2$
that are related by subtype relation:
$p\preceq\/p_1\preceq\/p_2$. This condition restricts the domain and
range to be defined on the same path from $p$ to some maximal element
$m$ of the predicate $p$ poset. 


The above Rule \ref{rul:3-stored1} generates all valid schema types of
a triple $t$. From the set of all valid stored types of $t$ we select
the subset including only the minimal types. The following rule is a
logical judgment for a minimal schema type of a $t$. 

\begin{equation}
\label{rul:min-stored-type}
\dfrac{t\in\T_i\quad T\in\T,\, t:_\uarr\/T\quad\/S_i^{\s\/i\in[1,n]}\in\T,\, t:_\uarr\/S_i\quad T\preceq\/S_i\lor\/T\not\sim\/S_i}
      {t:_{\uarr}\/T}
\end{equation}

The first part of the premise says that $t$ is a ground triple and there
exists $T\in\T$ which is a type of $t$. The second part of the premise
requires that $T$ is the minimal type of all types $S$ of $t$. In
other words, there is no type $S_i^{\s\/i=1..n}$ of $t$ that is a
subtype of $T$. Hence, $T$ is the minimal type of the stored triple
types of $t$.

Note that if the schema is defined by using RDF-Schema, and the stored
schema typing is correct, then the condition $T\sim\/S_i$ is always
$true$, and Rule \ref{rul:min-stored-type} generates exactly one
minimal type. Furthermore, under the restrictions of RDF-Schema, we can
not define a predicate $p$ with two meanings. If we were to specify two
different domains or ranges of $p$, then the reasoner would treat the
domain and range types as $\land$-types. Each instance of the domain
(range) type has to be an instance of all specified types of the
domain (range).

% 



\subsubsection{\ref{sec:stored-3types}.2 KGs with the contextual representation.}
% checked g

The collective findings of the research in the area of Cognitive
Science \cite{Hollister2017} shows that natural language is inherently
contextual, and the context is essential in the human representation
of knowledge and reasoning. 

While the current trend is to enforce exactly one meaning of a
predicate in KGs, the contextual representation and reasoning allow
the definition of multiple senses of a predicate. There are many
motivations for adopting contextual representation and reasoning in a
KG. First, with the evolution of KGs, there are many examples where a
KG is represented in a modular way, splitting the dataset into parts
that correspond to the contexts. The meaning of a predicate can be
different in different contexts, while the reasoner is able to
disambiguate among the different meanings of a predicate.
The practical examples of KGs using contexts include the named graphs
in DBpedia \cite{Auer2007}, Wikidata \cite{vrandecic2014}, and Yago
\cite{Hoffart2013}. Another example is Cyc \cite{cyc} that uses
microtheories to represent different contexts. Similar to Cyc, Scone
\cite{Fahlman2011} is a KR system that can define spaces (contexts)
and uses contextual reasoning.

The second motivation for using contextual representation of KGs is
the problem of a predicate with multiple senses represented with
multiple sub-predicates. In a query---whether expressed in natural
language, logic or as a database query---it is difficult to
disambiguate the correct sub-predicate for the particular query. The
alternative is that a user must explicitly select a correct sense of
a predicate (i.e., a sub-predicate) in the query.

Finally, a predicate can be compared to a mathematical function since
it represents a binary relation. In mathematics, a function is not
represented by its name only, but with a function type including,
besides the function name, also the types of its domain and
range. Types of functions can disambiguate among the different
functions with the same name but different domain and range
types. Similarly, the types can be effectively used to disambiguate
the meaning of the predicate in a KG.

To be able to study the behavior of KG predicates with multiple senses
in the presence of triple types, we propose a minimal KR schema
language that includes the triple types stored in a KG as triples. In
case there is more than one triple type including a predicate $p$,
then these are treated as alternatives. For example, if a KG includes
triples $(T_1,p,T_2)$ and $(T_3,p,T_4)$, where
$T_j^{\s\/j=1..4}\in\T_i$, then the type of ground triples including
$p$ is $T_1*p*T_2\lor\/T_3*p*T_4$.

Further, the proposed KR language can use $\land$ and $\lor$-types in
subject and object components of triple types. The $\land$ and
$\lor$-types are often implemented in KGs in the form of OWL type
constructors owl:intersectionOf and owl:unionOf\footnote{The OWL union
  and intersection type constructors are employed mostly in domain-specific KGs like biomedical and genomic ontologies. In these
  scientific fields, the knowledge base includes large ontologies where
  new classes can be defined as logical combinations of existing
  classes.} The use of $\lor$-type in place of the domain or range
type is redundant since it can be expressed with multiple triple
types. Hence, the \emph{minimal KR schema language} includes solely
the triple types of the form
$$\textstyle\bigwedge_{i=1}^n\/D_i*p*\bigwedge_{j=1}^m\/R_j.$$

Let us now present the rules that derive the stored types of a ground
triple $t$ in the case our minimal KR schema language is used for the
definition of the KG schema. First, the following Rule
\ref{rul:3-stored2} generates all valid alternatives of stored triple
types given a triple $t$. Note that $D_i$ and $R_i$ are the types of
domains and ranges of $p$ that can stand for a $\land$-type.

\begin{equation}
\label{rul:3-stored2}
\dfrac{t\in\V_t,\, t=(s,p,o)\quad T_i^{\s\/i=1..n}\in\T_t,\, T_i=(D_i,p,R_i)\quad\/T_i^{\s\/i=1..n}\in\Delta}
      {t:_\uarr\/\bigvee_{i=1}^n\/T_i}
\end{equation}

A schema triple type $\bigvee_{i=1}^nT_i$ of $t$ is a disjunction of
all valid schema triple types of $t$. Similar to Rule \ref{rul:min},
which is defined to find minimal types of a set of classes, the
following Rule \ref{rul:3-min} generates the disjunction of minimal
schema types.

\begin{equation}
\label{rul:3-min}
\dfrac{t\in\V_t\quad\/t:_\uarr\bigvee_{i=1}^n\/T_i}
      {t:_{\Darr}\bigvee\{S \mid S\in\/\{T_i\}_{i=1}^n\land\forall\/i=1..n,\, S\preceq\/T_i\lor\/S\not\sim\/T_i\}}
\end{equation}

The rule says that the triple types $S$ are minimal schema types of a
schema type $\bigvee_{i=1}^n\/T_i$. $S$ is minimal since all other
types $T_i$ are either more general or equal ($\succeq$), or not
related to $S$. 





\subsection{Typing a triple}

Before we present the final step in typing a triple $t$, an overview
of the work done so far is given. First, we derive the ground type of
the triple $t$ and then infer the minimal upper bound of the ground
type. The ground typing inspects all ground types of $t$'s
components. In case the MUB type is close to $\top$ type, then there is
an outlier in the set of ground types, it can be revealed in
the computation of the MUB type. 

Second, the schema type of $t$ is derived from the schema of a KG. In
case we use RDF-Schema semantics of a KG then the rules infer a single
minimal schema type. If there is more than one schema type, then the
domains and ranges from the different definitions are merged into one
$\land$-type. At this point, we can not verify if there are any errors
in types from the domain and/or range of a predicate. in schema
(stored) typing. In case we use RDF-Schema with $\land$ and $\lor$
types, then the rules can infer multiple disjunctive schema
types. Also in this case, there are no additional constraints that
could be verified.

Let us now present the final typing of $t$ by relating the ground type and
schema types (minimal schema triple types) via the subtyping relation. If
the RDF-Schema semantics are used, then we have a single schema type
which should be related to the ground type of $t$. The following Rule
\ref{rul:3-typing-one} derives the final type of $t$ under RDF-Schema
semantics. 

\begin{equation}
\label{rul:3-typing-one}
\dfrac{t\in\T_i\quad T\in\T_t,\, t:_{\darr}T\quad S\in\T_t,\, t:_\uarr\/S\quad T\preceq\/S}
      {t:S}
\end{equation}

The type of $t$ is computed by first deriving the ground type $T$ and
the schema type $S$ of $t$. $S$ is the final type of $t$ if $T$ is a
subtype of $S$. In case $T\not\preceq\/S$, then the ground type
$T=\land[T_i^{i\in[1,n}]$ includes at least one $T_i\not\preceq\/S$.

Let's assume now that the RDF-Schema together with $\land$-$\lor$ types are used to define the semantics of KG. In particular, assume that
we use the \emph{minimal KR schema language} as defined in Section
\ref{sec:stored-3types}.2. Note also that to derive the schema triple
type we have to use Rules \ref{rul-3-stored2}-\ref{rul:3-min}. The
rule for selecting the final type of $t$ is now as follows.

\begin{equation}
\label{rul:3-typing-two}
\dfrac{t\in\T_i\quad t:_{\darr}T\quad\/t:_\uarr\bigvee_{j=1}^{m}\/S_j}
      {t:\bigvee_{j=1}^m\{S_j \mid T\preceq\/S_j\}}
\end{equation}

Only those types $S_j$ that are linked to $T$ via the poset hierarchy
of types are gathered in the final type. This means that the ground
triple selects, via its type, the meaning of the predicate $p$.

The examples of final types that include more than one alternative
type with different meanings can appear when typing basic graph
patterns. In case a triple pattern includes one or more variables,
then the ground type of a triple component can not be
derived. Hence, we can not select precisely one schema type of $t$.






\section{Related work\label{sec:related}}

Most of the related work is cited in the text when presenting the
particular topic. In this section, we present only the work that is not
directly related to the presented work but represents a contribution
to the typing of the knowledge graphs.

The entity typing and type inference deal with predicting and
inferring the types (classes) of entities that are either missing or
incorrect. The automatic type assignment can use logic-based
assignment where a reasoner infers the type of an entity from the
schema \cite{Horrocks2003}. Alternatively, the rule-based inference
can be employed on the rules defined as a schema by knowledge
engineers \cite{Horrocks2004}. Reasoners use them
automatically. Another alternative is the use of ML-based type
prediction \cite{Yaghoobzadeh2018}. Various techniques can be used, like entity embeddings and graph neural networks, to produce embeddings
to be fed into the classifier.

The schema-based type checking is about the verification of RDF-Schema
\cite{rdfschema12} and OWL \cite{owl2} rules and constraints against
the data (ABox) and schema (TBox) parts of a KG
\cite{Baader2002,Horrocks2003,OWL2Spec2012}. The domain and range
types of predicates are checked to determine whether they are correctly interpreted
among the ground triples of a KG. The consistency of subtyping and
inheritance is verified in the KG schema and in the data. Similarly,
the disjointness of types and other OWL constraints is
checked. Most of the presented themes are covered by tools based on
SHACL \cite{shacl2017} and ShEx \cite{shex2015}.

Type checking in query answering ensures that the variables and
results of a query over a KG are consistent with the schema of a KG
\cite{Zhao2017,Zhang2019}. A type-checker for queries requires that a
query respects class hierarchies, domain/range constraints, and
disjointness rules. The type information can also be used to improve
the query optimization and execution. In \cite{Kollia2013}, they
propose to leverage type information to optimize query execution and
filter semantically invalid results. In most cases, the presented
approaches use fragments of types that are adapted for the particular
problem.





\section{Conclusions\label{sec:conclude}}

Typing of a knowledge graph can serve many theoretical and practical
purposes. First, type-based inference can be used for answering
logical queries about the KG domain by inferring from parts
of schema, like the poset of types, the domain and range constraints,
and the stored typing of identifiers. Second, typing of a KG can be
extended to type-checking that can identify inconsistencies in a
KG. Third, typing a KG can be used as the basis for typing basic graph
patterns and SparQL, and with this, they also can be used in tasks
such as the query optimization and reasoning.


... \\





% \section{Acknowledgments}
%
%The authors acknowledge the financial support from the Slovenian Research Agency (research core funding No. P1-00383).

\bibliographystyle{abbrv}
\bibliography{biblio}

\end{document}



