\documentclass[a4paper,twoside]{article}

\usepackage{epsfig}
\usepackage{subcaption}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{multicol}
\usepackage{pslatex}
\usepackage{apalike}
\usepackage{algorithm2e}
\usepackage[bottom]{footmisc}
% my
\usepackage{times}
\usepackage{latexsym}
%\usepackage[T1]{fontenc}
%\usepackage[noend]{algpseudocode}
%\usepackage{algorithm}
%\usepackage{graphicx}
%\usepackage{wrapfig}
%\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
%\usepackage{graphics}
%\usepackage{color}
\usepackage{url}
%
\usepackage{SCITEPRESS}     % Please add other packages that you may need BEFORE the SCITEPRESS.sty package.

% symbols
%\newcommand{\epsln}{$\epsilon$\emph{psilon} } 
\newcommand{\epsln}{\emph{epsilon} } 
\newcommand{\s}{\scriptscriptstyle\ \,} 
\newcommand{\ul}{\underline} 
\newcommand{\ol}{\overline} 
\newcommand{\darr}{\downarrow} 
\newcommand{\uarr}{\uparrow} 
\newcommand{\Darr}{\Downarrow} 
\newcommand{\Uarr}{\Uparrow} 
\newcommand{\llb}{\llbracket}
\newcommand{\rrb}{\rrbracket}
\newcommand{\vdasharr}{%
    \mathrel{%
        \vdash\hspace*{-5pt}%
        \raisebox{2.3pt}{\scalebox{.5}{\(\blacktriangleright\)}}%
    }%
  }
\newcommand{\DD}{{\Delta}} 
\newcommand{\U}{{\cal U}} 
\newcommand{\B}{{\cal B}} 
\newcommand{\Lt}{{\cal L}} 
\newcommand{\St}{{\cal St}} 
\newcommand{\Pt}{{\cal Pt}} 
\newcommand{\Ot}{{\cal Ot}} 
\newcommand{\V}{{\cal V}} 
\newcommand{\Vl}{{\cal V}_l} 
\newcommand{\Vi}{{\cal V}_i} 
\newcommand{\Vt}{{\cal V}_t} 
\newcommand{\Vp}{{\cal V}_p}
\newcommand{\TT}{{\cal T}}
\newcommand{\TTi}{{\cal T}_i}
\newcommand{\TTt}{{\cal T}_t}
\newcommand{\cl}{\text{:}} 
\newcommand{\rdftype}{\text{rdf:type}} 
\newcommand{\rdfsubcl}{\text{rdfs:subClassOf}} 
\newcommand{\rdfsubclpl}{\text{rdfs:subClassOf+}} 
\newcommand{\rdfsubprop}{\text{rdfs:subPropertyOf}} 
\newcommand{\rdfsubproppl}{\text{rdfs:subPropertyOf+}} 
\newcommand{\rdfsdomain}{\text{rdfs:domain}} 
\newcommand{\rdfsrange}{\text{rdfs:range}} 
\newcommand{\finbox}{\phantom{.}\hfill\Box}
\newcommand{\vb}[1]{\begin{small}\texttt{#1}\end{small}}
\newcommand{\lub}{l}
\newcommand{\memo}[1]{}
\newcommand{\notes}[1]{\noindent\begin{small}-- \emph{#1}\hfill\break\end{small}}
\newcommand{\nnotes}[1]{\indent\begin{small}-- \emph{#1}\hfill\break\end{small}}
\newcommand{\nnnotes}[1]{\indent\indent\begin{small}-- \emph{#1}\hfill\break\end{small}}
\newcommand{\anotes}[1]{\indent\begin{small}\phantom{-- }\emph{#1}\hfill\break\end{small}}
\newcommand{\ennotes}[1]{\indent\begin{small}-- \emph{#1}\hfill\end{small}}
\newtheorem{example}{Example}

%\def\ojoin{\setbox0=\hbox{$\bowtie$}%
%  \rule[-.02ex]{.25em}{.4pt}\llap{\rule[\ht0]{.25em}{.4pt}}}
%\def\leftouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie}}
%\def\rightouterjoin{\mathbin{\bowtie\mkern-5.8mu\ojoin}}
%\def\fullouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie\mkern-5.8mu\ojoin}}


\begin{document}

\title{A type system for knowledge graphs}

\author{\authorname{Iztok Savnik\orcidAuthor{0000-0002-3994-4805}}
\affiliation{Department of computer science, \\
  Faculty of mathematics, natural sciences and information technologies, \\
  University of Primorska, Slovenia}
\email{iztok.savnik@upr.si}
}

\keywords{Knowledge graphs, Knowledge representation, Type systems}

\abstract{
  This paper presents a formal type system for knowledge graphs (KGs).
  The schema of a KG represents a language of types comprising the
  type identifiers---such as classes and predicates---ordered into
  taxonomies, together with the product, intersection, and union
  types. To handle the rich hierarchy of types, the typing framework
  employs algebraic operators on posets to formalize typing relations.
  Typing of ground triples proceeds by first inferring and minimizing
  the ground type from the stored typing of entities, then
  generalizing it to a minimal upper bound (MUB) type. The MUB type
  serves as a basis for relating ground types to the schema of a
  KG. Next, the schema type is inferred from the predicate’s
  definition, minimized, and filtered through subtyping with respect
  to the MUB ground type to produce the final schema type. The
  proposed typing rules support type inference, provide a framework
  for type-checking of KGs and graph patterns, and enable predicate
  disambiguation based on the triple types.}

\onecolumn \maketitle \normalsize \setcounter{footnote}{0} \vfill




\section{Introduction}

A knowledge graph (abbr., KG) is a formalism for representing data and
knowledge in the form of a graph. The vocabularies, such as RDF-Schema
\cite{rdfschema}, attach the meanings to the edges of a graph, and
turn a graph into a language for the representation of data and
knowledge. The expressive power of a KG can be observed from KG's
relation to logic. From this perspective, a KG is a set of named
binary relations, and triples are logical statements. Let us present
some of the features of the data and knowledge representation language
of a KG.

First, a KG stores predefined classes that are organized into
taxonomies \cite{Baader2002}. Second, typing of ground identifiers, as
well as typing of the predicates with the domain and range types, is
stored in a KG. Further, similarly to the \emph{roles}
\cite{Brachman1985} of a knowledge base, the predicates are treated as
classes. As classes, predicates are organized into a txonomy. However,
they also act as individual entities described with additional
predicates. Finally, the predicates are inherited through the taxonomy
of classes similarly as data members and methods are inherited from
classes of object-oriented programming languages. And since predicates
also act as classes, the predicates of the predicates, like the domain
and range of a predicate, are inherited through the taxonomy of
predicates.

From a logic perspective, the schema of a KG represents the
definitions of concepts (classes) and binary relations (predicates);
this is often referred to as the intensional knowledge. On the other
hand, the ground entities (identifiers) and ground triples represent
the facts about the entities, or the extensional knowledge.

From the perspective of a type system, the schema of a KG is presented
by using a language of types \cite{Pierce2002}, often the
RDF-Schema. The syntax of type expressions includes the following
structures. First, we have classes that are the types of ground
identifiers (entities). Second, the predicates are the identifiers
(names) of binary relations. The types of predicates are the product
types, including the domain and range types and the associated
predicates. Further, the $\land$-$\lor$ types \cite{Pierce1996}
capture many requirements of the KG domain very naturally. For
example, a domain of a predicate can be two different classes that are
linked by an $\land$-type.

Finally, the taxonomies of classes and predicates are hard to grasp
structurally; rather, posets can be manipulated with algebraic
operators. In the proposed type system, we often use the operators that
are defined on posets. The algebraic operators employed in the rules
include the operator \emph{minimum}, which given a poset returns a set
of minimal poset elements, and the operator for computing
\emph{minimal upper bounds} of a subset of elements from a poset
\cite{DaveyPriestley2002}.

The paper presents a type system comprising a set of rules for typing
ground triples from a KG. Let us give an abstract description of
typing a single ground triple $t$. First, the \emph{ground type} of
$t$ is inferred bottom-up, from the stored typing of ground
entities, which are the components of $t$. The ground type is further
minimized to obtain a minimal ground type of $t$. The minimal ground
type is then generalized to obtain a minimal upper bound (MUB)
type. The MUB type is an appropriate starting point for exploring its
relations to the conceptual schema of a knowledge graph. Second, the
\emph{schema type} of $t$ is inferred from the conceptual schema based
on the predicate of $t$. All valid schema types of $t$ are gathered
and then minimized to obtain a schema type with a minimal
interpretation. Finally, the minimal schema type is filtered by
relating it to the MUB ground type via the subtype relation to compute
the \emph{final schema type} of $t$.

The contributions of the presented research are as follows. First, to
our knowledge, this is the first proposal for typing ground triples of
a knowledge graph that uses the product, union and intersection types,
and encompasses a complete KG. Second, the presented framework for
typing ground triples can serve conveniently for the implementation of
type-checking the stored typing of a KG. The analysis of typing a
ground triple spans from the ground types at the lower levels of
ontology to the minimal schema types at the upper levels of
ontology. Finally, we show that the triple types can be used to
disambiguate the sense of a predicate with multiple meanings.

The paper is organized as follows. The following Section
\ref{sec:prelim} presents definitions of an RDF graph, a KG data model,
and the typing rule language. Next, typing of identifiers is presented
in Section \ref{sec:typ-idents}. Here we present typing literals and
introduce typing and subtyping of identifiers. In Section
\ref{sec:intsc-union} we present the semantics of $\land$-$\lor$
types, the associated rules for typing and subtyping, and introduce
the join and meet types. Typing of triples is described in Section
\ref{sec:triples}. We present the derivation of ground and schema
triple types, and the rules to combine these two into the final
type. Section~\ref{sec:related} presents an overview of the related
work on typing KGs. Finally, in Section \ref{sec:conclude} we discuss
some directions of further work. 





\section{Preliminaries\label{sec:prelim}}

In this Section, we present the definition of an RDF graph, a data model
of a KG, and the typing rule language that we use in the sequel.



\subsection{RDF graph\label{sec:kg}}

An RDF graph \cite{rdf} is defined as follows. Let $I$ be a set of
URI-s, $B$ be a set of blanks, and $L$ be a set of literals. Let us
also define sets $S = I\cup\/B$, $P = I$, and $O =
I\cup\/B\cup\/L$. An \emph{RDF triple} is a triple
$(s,p,o)\in\/S\times\/P\times\/O$. An \emph{RDF graph}
$g\subseteq\/S\times\/P\times\/O$ is a set of triples. A set of all
graphs will be denoted as $G$.

The complete set of triples of an RDF graph is in the text
referred to as $\Delta$. We use $\Delta$ when we want to refer
to the original set of KG triples and not the data model of a KG
presented in the following Section.






\subsection{A data model of a KG}

This Section defines a knowledge graph as an RDF graph that uses the
RDF-Schema vocabulary \cite{rdfschema} for the representation of the
schema part of a knowledge graph. To abstract away the details of the
RDF data model, we unify the representation of the knowledge graph by
separating solely between the \emph{identifiers} and the
\emph{triples}.

The identifiers include the set of ground (individual) identifiers,
i.e., identifiers that denote individual entities, and the set of type
identifiers, i.e., the identifiers that denote the types of individual
entities. The triples include the set of ground triples and the set of
triple types.

However, typing of a KG is based on the separation between the values
$\V$ and the types $\TT$. The set of values $\V$ includes the ground
identifiers $\V_i$ and the ground triples $\V_t$. To be able to refer
to the specific subsets of $\V_i$ in the rules, we also introduce the
set of literal values $\V_l\subseteq\V_i$, and the set of predicates
$\V_p\subseteq\V_i$. The set of all valid types $\TT$ comprises the
type identifiers $\TT_i$, i.e., types of ground identifiers $\V_i$, and
the triple types $\TT_t$, i.e., the types of ground triples $\V_t$.
Finally, a set $\TT_c\subseteq\TT_i$ is a set of class identifiers, and
a set $\TT_p\subseteq\TT_i$ denotes a set of predicates that now have
the role of types.

The set of type identifiers $\TT_i$ is ordered by a subtype relation
$\preceq$ to form a poset. The meaning of type identifiers is
established by their interpretations. The interpretation of a type
identifier $T_i\in\TT_i$ is the set of its instances, including the
instances of type identifiers $T_i'\preceq\/T_i$.

The ground triples include solely the ground identifiers from $\V_i$
in places of S and O, and predicates $\V_p$ in the place of P
component of a triple. The types of ground triples are the product
types $T_s*p*T_o$ where $T_s\in\TT_c$, $T_o\in\TT_c\cup\TT_l$. and
$p\in\TT_p$. The product types are in our data model, written as
triples $(T_s,p,T_o)$. In Section \ref{sec:intsc-union}, we extend
triple types with $\land$-$\lor$ types in the subject and object
components.

The triple types $\TT_t$ are ordered by a subtype relation $\preceq$ to
form a poset. The subtype relation $\preceq$ among the triple types is
induced from a subtype relation defined among the type identifiers
$\TT_i$. A more detailed formal definition of a KG is given in
\cite{Savnik2025}.




\subsection{Typing rule language}

We depart from the standard typing-rule notation with contexts
($\Gamma$) \cite{Pierce2002,Hindley1997} and instead employ a
meta-language rooted in first-order logic (FOL). This meta-language is
inspired by Pierce’s presentation of typing rules \cite{Pierce2002},
especially in the treatment of records, subtyping, and universal
quantification.

The rules are composed of a set of premises and a conclusion. The
premises can be expressions stating the set membership of objects,
typing and subtyping judgements, or expressions in the FOL, including
the previous two forms. The expressions of FOL can express complex
premises, such as, for example, the conditions for the LUB types. The
conclusion part of the rule is a typing or subtyping judgment.

The symbols used in a rule are grounded by stating their membership in
the sets of identifiers ($\V$, $\V_i$, and $\V_t$) and triples ($\TT$,
$\TT_i$ and $\TT_t$) defined in Section \ref{sec:kg}. When we write
$o\in\/s$, then we mean the \emph{existence} of an object $o$ in a set
$s$. We use universal quantification $\forall\/o\in\/s,\ p(o)$ when we
state that some property $p(o)$ holds for all objects $o$ from
$s$. The premises of the rule are treated from left to right. The
quantification of the symbols binds the symbols up to the last premise
unless defined differently by the parentheses.

The usual typing relation $x:T$, saying that $x$ is of type $T$, can
be annotated to obtain a specific typing relation $x:_*\/T$, where $*$
stands for any annotation. All annotated typing relations $x:_*\/T$
imply a usual typing relation $x:T$. The annotation is needed since we
construct the final type of a triple $t$ from two different types, the
ground type $t:_\darr\/T_g$ and schema type $t:_\uarr\/T_s$. Moreover,
the annotation is also employed to guide the application of
some specific rules. All the annotated typing relations are introduced
before their use.









\section{Typing identifiers\label{sec:typ-idents}}

In this section, we present the typing of ground identifiers
$\V_i$. First, typing of literals $\V_l$ is described in Section
\ref{sec:literals}. Next, the rules for ground typing and subtyping of
ground identifiers are presented in Section
\ref{sec:idents-stored}. Section \ref{sec:idents-typing} further
extends ground typing and subtyping to the complete set of type
identifiers $\TT_i$.





\subsection{Typing literals\label{sec:literals}}

Literal values $\V_l\subseteq\V_i$ are the instances of literal types
$\TT_l\subseteq\TT_i$. The literal types $\TT_l$ are provided by the
RDF-Schema vocabulary \cite{rdfschema}. RDF-Schema defines a rich set
of literal types, such as xsd:integer, xsd:string, or xsd:boolean.

The literals are composed of literal values and literal types. For
example, the literal
"365"\textasciicircum\textasciicircum\/xsd:integer includes the
literal value "365" and a type xsd:integer. Typing of literals is
defined by the following rule.

\begin{equation}
\dfrac{L\in\V_l\quad T\in\TT_l\quad \text{"L"\textasciicircum\textasciicircum\/T}\in\Delta}
      {L:T}  
\end{equation}

The rule states that a literal value $L$ is of a type $T$ if a literal
"L"\textasciicircum\textasciicircum\/T is an element of a KG
$\Delta$. A literal type $T$ is referencing a type from the RDF-Schema
vocabulary.






\subsection{Ground typing and subtyping of identifiers\label{sec:idents-stored}}

The typing expression $V:_\darr\/T$ denotes a \emph{ground typing}
relation $:_\darr$ that links a value $V\in\V_i$ to a ground type
identifiers $T\in\TT_i$. The ground typing relation is a \emph{one-step
  typing} relation based on typing stored in a KG.

The ground types are linked to the ground identifiers via a stored
typing relation in the form
$(I,\text{rdf:type},T)\in\Delta$. Consequently, we can write
$I:_\darr\/T$. The rule for the one-step ground typing relation
$:_\darr$ is defined as follows.

\begin{equation}
\label{rul:ident-1step-type}
\dfrac{I\in\V_i\quad T\in\TT_i\quad (I,\text{rdf:type},T)\in\DD}
      {I :_\darr T}
\end{equation}

The individual entity $I$ can have more than one stored type. By
using Rule \ref{rul:ident-1step-type} as a generator, it synthesizes
all types $T_j^{j\in[1,n]}$ such that $I:_\darr\/T_j^{j\in[1,n]}$.

If we want to obtain all valid ground types of $I$, the rule can be
used either in some other rule that employs it as a generator, or we
can update the above rule to generate an $\land$-type, including all
the ground types of $I$ as presented in Section \ref{sec:intsc-union}.

The one-step subtyping relation $\preceq_\darr$ is defined on
classes by using the RDF predicate rdfs:sub\-ClassOf as follows.

\begin{equation}
\label{rul:ident-1step-subtype}
\dfrac{C_1,C_2\in\TT_c\quad (C_1,\text{rdfs:subClassOf},C_2)\in\DD}
{C_1 \preceq_\darr\/C_2}
\end{equation}

The rule for the definition of the one-step subtyping relationship
$\preceq_\darr$ on the predicates $\TT_p$ is based on the RDF-Schema
predicate rdfs:subPropertyOf.

\begin{equation}
\dfrac{P_1,P_2\in\TT_p \quad (P_1,\text{rdfs:subPropertyOf},P_2)\in\DD}
      {P_1\preceq_\darr\/P_2}
\end{equation}

The predicates have in the above rule the role of types in the sense
that they represent the names of the binary relations. 



\subsection{Typing and subtyping identifiers\label{sec:idents-typing}}

The one-step relation $\preceq_\darr$ is extended with the
reflectivity, transitivity, and antisymmetry to obtain the subtyping
relation $\preceq$. The relation $\preceq$ forms a poset of type
identifiers $\TT_i$.

First, the one-step relation $\preceq_\darr$ is generalized to the
relation $\preceq$ defined over type identifiers $\TT_i$.

\begin{equation}
\label{rul:Ic-extended}
\dfrac{I_1,I_2\in\TT_i \quad I_1\preceq_\darr\/I_2}
      {I_1 \preceq I_2}
\end{equation}

The following Rules \ref{rul:Ti-reflexivity}-\ref{rul:Ti-antisymmetry}
define the reflexivity, transitivity and antisymmetry of the
relation $\preceq$, respectively.

\begin{equation}
\label{rul:Ti-reflexivity}
\dfrac{I\in\TT_i}
      {I\preceq\/I}
\end{equation}

\begin{equation}
\label{rul:Ti-transitivity}
\dfrac{I_1,I_2,I_3\in\TT_i\quad\/I_1\preceq\/I_2\quad\/I_2\preceq\/I_3}
      {I_1\preceq\/I_3}   
\end{equation}

\begin{equation}
\label{rul:Ti-antisymmetry}
\dfrac{I_1,I_2\in\TT_i \quad I_1\preceq\/I_2 \quad I_2\preceq\/I_1}
      {I_1=I_2}   
\end{equation}

\noindent
As a consequence of Rules
\ref{rul:Ti-reflexivity}-\ref{rul:Ti-antisymmetry}, the relation
$\preceq$ orders the types from $\TT_i$ into a poset.

The one-step typing relation $:_\darr$ is generalized to the typing
relation $:$ with the following rule.

\begin{equation}
\dfrac{I\in\V_i\quad\/T\in\TT_i\quad\/I:_\darr\/T}
      {I:T}
\end{equation}

Note that a unique notation for ground typing allows us to address
differently the \emph{stored} and the \emph{derived} types of ground
identifiers.

The link between the typing relation $:$ and the subtype relation
$\preceq$ is provided by adding a typing rule called the \emph{rule of
  subsumption} \cite{Pierce2002}.

\begin{equation}
\label{rul:typing-subsumption}
\dfrac{I\in\TT_i\quad\/S,T\in\TT_i\quad\/I:S\quad\/S\preceq\/T}
      {I:T}    
\end{equation}

Finally, KGs include a special class $\top$ that represents the root
type of an ontology. In RDF ontologies, $\top$ is usually represented
by the predicate owl:Thing \cite{Hoffart2013}. The following rule
specifies that all types are subtypes of $\top$.

\begin{equation}
\dfrac{\forall\/S\in\TT}
      {S\preceq\top}
\end{equation}






\section{Intersection and union types\label{sec:intsc-union}}

The rules for the $\land$ and $\lor$-types presented in this section
are general---they apply for the type identifiers $\TT_i$ and triple
types $\TT_t$.

The meaning of the $\land$ and $\lor$-types can be seen through their
interpretations. The instances of the intersection type
$T_1\land\/T_2$ are objects belonging to both $T_1$ and $T_2$. The
type $T_1\land\/T_2$ is the greatest lower bound of the types $T_1$
and $T_2$. In general, $\land_{i=1}^n\/T_i$ is the greatest lower
bound (abbr. GLB) of types $T_i^{\s\/i=1..n}$
\cite{Pierce1991,Pierce1996}. The instances of the type
$\land_{i=1}^n\/T_i$ form a maximal set of objects that belong to all
types $T_i$.

The union type is dual to the intersection type. The instances of the
union type $T_1\lor\/T_2$ are objects from the interpretations of both
types, $T_1$ and $T_2$. The type $T_1\lor\/T_2$ denotes the least
upper bound of types $T_1$ and $T_2$. A general form of union type is
$\lor_{i=1}^n\/T_i$. The interpretation of $\lor_{i=1}^n\/T_i$
represent the minimal set of instances that include the instances of
all types $T_i^{\s\/i=1..n}$.

The interpretation of a type $\land_{i=1}^n\/T_i$ is included in
interpretation of every particular type $T_i$ which means
$\land_{i=1}^n\/T_i\preceq\/T_i$. This is stated by the following
rule.

\begin{equation}
\label{rul:land-preceq-elems}
\dfrac{T_i^{\s\/i=1..n}\in\TT}
      {\land_{i=1}^n\/T_i\preceq\/T_i^{\s\/i=1..n}} 
\end{equation}

Further, the following rule states that if the type $S$ is a subtype
of every type $T_i^{\s\/i=1..n}$ then $S$ is a subtype of
$\land_{i=1}^n\/T_i$.

\begin{equation}
\label{rul:lbound-preceq-land}
\dfrac{S\in\TT\quad\/T_i^{\s\/i=1..n}\in\TT\quad\/S\preceq\/T_i^{\s\/i=1..n}}
      {S\preceq\land_{i=1}^n\/T_i}  
\end{equation} 

The opposite of the above rule, the following rule states the
necessary conditions that must be met so that a type $T$ is a
supertype of a type $\land_{i=1}^n\/S_i$. It is enough that there is
one type $S_i\preceq\/T$ for the intersection of $S_i^{\s\/i=1..n}$ to
be included in $T$.

\begin{equation}
\label{rul:land-preceq-ubound}
\dfrac{T\in\TT\quad\/S_i^{\s\/i=1..n}\in\TT\quad\/S\in\{S_i\}_{i=1}^n\quad\/S\preceq\/T}
      {\land_{i=1}^n\/S_i\preceq\/T}  
\end{equation} 

The duality of the intersection and union types can also be seen from
the duality of the rules for the $\land$ and $\lor$-types.

The union type $\lor_{i=1}^n\/T_i$ is the least upper bound of types
$T_i^{\s\/i=1..n}$ \cite{Pierce1991}. This means that all types
$T_i^{\s\/i=1..n}$ are subtypes of their union.

\begin{equation}
\label{rul:lor-preceq-elems}
\dfrac{T_i^{\s\/i=1..n}\in\TT}
      {T_i^{\s\/i=1..n}\preceq\lor_{i=1}^n\/T_i}
\end{equation}

The following rule defines the necessary conditions to be met for a
type $T$ to be a supertype of a type $\lor_{i=1}^n\/S_i$.

\begin{equation}
\label{rul:lor-preceq-ubound}
\dfrac{T\in\TT\quad\/S_i^{\s\/i=1..n}\in\TT\quad\/S_i^{\s\/i=1..n}\preceq\/T}
      {\lor_{i=1}^n\/S_i\preceq\/T}  
\end{equation}

Again, the opposite rule defines the premises that must hold so that
$S$ is a subtype of a type $\lor_{i=1}^n\/T_i$.

\begin{equation}
\label{rul:lbound-preceq-lor}
\dfrac{S\in\TT\quad\/T_i^{\s\/i=1..n}\in\TT\quad\/T\in\{T_i\}_{i=1}^n\quad\/S\preceq\/T}
      {S\preceq\lor_{i=1}^n\/T_i}  
\end{equation}

Note that besides checking the subtype relation between a type treated
as a whole and some logical type, Rules
\ref{rul:land-preceq-elems}-\ref{rul:lbound-preceq-lor} can be used to
check the subtyping among arbitrary logical types.






\subsection{The join and meet types\label{sec:join-meet-types}}

The $\lor$ and $\land$ types are logical types defined on the basis of
their interpretations, i.e., the sets of instances. Given two types
$T$ and $S$ we have a least upper bound $S\lor\/T$, and a greatest
lower bound $S\land\/T$ types where $S\lor\/T$ denotes a minimal set
of objects that are of type $S$ \emph{or} $T$ (or both), and
$S\land\/T$ denotes a maximal set of objects that are of type $S$
\emph{and} $T$.

A KG includes a stored poset of classes and triple types that
represent types of the individual identifiers and ground triples. The
poset can be used to compute a join $S\sqcup\/T$ and a meet
$S\sqcap\/T$ of the parameter types. The usual definition of the join
and meet operators is by using a least upper bound and a greatest
lower bound if they exist \cite{Pierce2002}, respectively. However, in
a KG, we are also interested in the upper bound and lower bound types
\cite{DaveyPriestley2002}. Let us present an example.

\begin{example}
  Let $P=(U,\preceq)$ be a partialy oredered set such that
  $U=\{a,b,c,d,e\}$ and the relation
  $\preceq=\{a\preceq\/c,a\preceq\/d,b\preceq\/c,b\preceq\/d,c\preceq\/e,d\preceq\/e\}$.
  The upper bounds of $S=\{a,b\}$ are the elements $c$ and $d$. Since
  there are no lower upper bounds, the upper bounds $\{c,d\}$ are
  minimal upper bounds. The least upper bound of $S$ is $e$.

  In the case that we remove the element $e$ from $P$, then $P$ does
  not have a least upper bound, but it still has two minimal upper
  bounds $c$ and $d$. $\finbox$
\end{example}

The least upper bound (abbr., LUB) is by definition one element. It
has to be related to all upper bounds via the relationship
$\preceq$. On the other hand, the most interesting upper and lower
bounds are minimal upper bounds (abbr., MUB) and maximal lower bounds
(abbr. MLB) \cite{Knudstorp2024}. They can be lower than the least
upper bound and higher than the greatest lower bound,
respectively. They represent more detailed information about the
parameter set of types $S$ than the LUB type of $S$.

The join $J=\sqcup_{i=1}^n\/T_i$ is a set of MUB types
$J_j^{j\in[1,m]}\in\/J$ such that $J_j$ is an upper bound with
$T_i^{\s\/i=1..n}\preceq\/J_j$, and there is no such $L$ where
$T_i^{\s\/i=1..n}\preceq\/L$ without also having
$J_j\preceq\/L$. Since we have a top type $\top$ defined in a KG, the
join of two arbitrary types always exist.

The meet of types $T_i^{\s\/i=1..n}$, $M=\sqcap_{i=1}^n\/T_i$, is a
set of the maximal lower bound types $M_j^{j\in[1,m]}\in\/M$ such that
$M_j$ is lower bound with $M_j\preceq\/T_i^{\s\/i=1..n}$, and all
other lower bounds $U$ with $U\preceq\/T_i^{\s\/i=1..n}$ entail
$U\preceq\/M_j$. Note that the meet of the set of types from a KG does
not always exist.

The join type is related to the $\lor$-type. Given a set of types
$\{T_i\}_{i=1}^n$, the join $J=\sqcup_{i=1}^n\/T_i$ is a set of types
$J_j^{j\in[1,m]}\in\/J$ that are the minimal upper bounds such that
$T_i^{\s\/i=1..n}\preceq\/J_j$. On the other hand, Rule
\ref{rul:lor-preceq-elems} for the $\lor$-types states
$T_i^{\s\/i=1..n}\preceq\lor_{i=1}^n\/T_i$. However, the join type and
$\lor$-type differ in the interpretation.
$$\llb\lor_{i=1}^n\/T_i\rrb_\DD=\bigcup_{i=1}^n\llb\/T_i\rrb_\DD\subseteq\bigcup_{j=1}^m\llb\/J_j\rrb_\DD=\llb\sqcup_{i=1}^n\/T_i\rrb_\DD$$

While the interpretation of the type $\lor_{i=1}^nT_i$ includes
precisely the instances of all $T_i$, the interpretation of the type
$\sqcup_{i=1}^n\/T_i$ contains the instances of minimal upper bound
types. The interpretation of $\sqcup_{i=1}^n\/T_i$ can include
interpretations of classes that are not among $T_i^{\s\/i=1..n}$.

A meet type of $T_i^{\s\/i=1..n}$ may not exist in a poset of types
from a KG. In general, the meet types $M=\sqcap_{i=1}^n\/T_i$ exist in
a class ontology if the types $T_i^{\s\/i=1..n}$ are \emph{bounded
  below} \cite{Pierce2002} which means that there exists a type $L$
such that $L\preceq\/T_i$ for all $i$. The meet types are not frequent
on the lower levels of a class ontology from a KG.

As in the case of the $\lor$-type and the join type, the semantics of
the $\land$-type is similar to the semantics of the meet type. An
$\land$-type is a type that implements logical view of the greatest
lower bound type. Differently, the meet types are based on the
concrete poset of KG types and represent concrete types though their
interpretation is contained in the interpretation of a
$\land$-type. The type $\land_{i=1}^n\/T_i$ denotes the intersection
$\bigcap\/\llb\/T_i\rrb_\DD$ while the interpretation of a meet types
$M_j^{\s\/j=1..m}\in\sqcap_{i=1}^n\/T_i$ includes the union
$\cup_{j\in[1,m]}\llb\/M_j\rrb_\DD$. Since
$M_j\preceq\/T_i^{\s\/i=1..n}$, then
$\llb\/M_j\rrb_\DD\subseteq\llb\/T_i^{\s\/i=1..n}\rrb_\DD$. Hence,
$\llb\sqcap[T_i^{\s\/i=1..n}]\rrb_\DD=\cup_{j=1}^m\llb\/M_j\rrb_\DD$

Note that the instances of the meet types are in the intersection of
the instances of the types $T_i^{\s\/i=1..n}$. The set
$\bigcap\/\llb\/T_i\rrb_\DD$ can also include objects that are not
instances of any meet type from $M$. Hence,
$$\llb\land_{i=1}^n\/T_i\rrb_\DD=\bigcap_{i=1}^n\llb\/T_i\rrb_\DD\supseteq\bigcup_{j=1}^m\llb\/M_j\rrb_\DD=\llb\sqcap_{i=1}^n\/T_i\rrb_\DD.$$

When typing the ground triples, the join types are used in the
procedure for checking the types derived bottom-up against the stored
schema of a KG as presented in Section~\ref{sec:3-ground-types}. The
join as well as meet types are useful in the procedure for
type-checking basic graph patterns \cite{Savnik2025a}. The $\lor$ and
$\land$-types are logical types that can be simplified in the typing
positions of a graph pattern by using typing rules, and can be
approximated by using join and meet types to obtain a more precise
concrete type of a graph pattern variable.




\subsection{Typing identifiers with $\land$-$\lor$ types}

The $\land$ and $\lor$-types can model the available choices in the
selection of the domain and range types of a triple type. The choices
depend on the selected model (e.g., RDF-Schema). As usual for the
expressions including a variant of $\cup$ and $\cap$ operators, more
complex expressions can be transformed by moving $\cup$ and $\cap$
either inside the expression or towards the outside of an
expression. We define the rules for these transformations only if they
are needed for typing ground triples.

We start with a rule for gathering the ground types of a ground
identifier $I\in\V_i$. The ground types are gathered in the premise of
the rule by selecting individual ground types as presented in Section
\ref{sec:idents-stored}.

\begin{equation}
\label{rul:land-1}
\dfrac{I\in\V_i\quad\/T_i^{\s\/i=1..n}\in\TT_i\quad\/I:_{\darr}T_i^{\s\/i=1..n}}
      {I:_{\darr}\land_{i=1}^n\/T_i}
\end{equation}

The ground type $\land_{i=1}^n\/T_i$ can include pairs of types
$T_i\preceq\/T_k$ with $i\not=k$. Depending on the further use, we can
either infer the \emph{minimal} or the \emph{maximal elements} of
$Q\subseteq\/P=\{T_i\}_{i=1}^n$ with respect to $\preceq$
\cite{DaveyPriestley2002}. The supertypes of the minimal elements of
$\{T_i\}_{i=1}^n$ include all valid types of $I$. Hence, we use the
set of minimal elements from $\{T_i\}_{i=1}^n$ as the starting point
to explore the relations between the ground types and the schema types
of a triple $t$.

Given a set of types $P=\{T_i\}_{i=1}^n$ ordered by $\preceq$ and a
set $Q\subseteq\/P$, the minimal elements of $Q$ are the elements
$S_j^{\s\/j=1..m}\in\{T_i\}_{i=1}^n$ such that
${\nexists}\/T_i^{\s\/i=1..n}(T_k\prec\/S_j)$. All pairs of types
$S_k,S_l\in\{S_j\}_{j=1}^m$ with $k\not=l$ are \emph{incomparable},
i.e.,
$S_k\not\sim\/S_l\equiv\/S_k\not\preceq\/S_l\land\/S_k\not\succeq\/S_l$.
The logical rule for deriving a minimal type of a ground type
$\land_{i=1}^n\/T_i$ is defined as follows.

\begin{equation}
\label{rul:min}
\dfrac{I\in\V_i\quad\/I:_\darr\land_{i=1}^n\/T_i}
      {I:_{\Darr}\land \{S \mid S\in\/\{T_i\}_{i=1}^n\land\forall\/i\in[1,n],\ S\preceq\/T_i\lor\/S\not\sim\/T_i\}}
\end{equation}

First, note that we used the annotated typing relation "$:_\Darr\/$"
to denote that we would like to infer the minimal type of $I$. The
rule says that the types $S$ gathered with the $\land$-type are the
minimal types of a set of ground types $\{T_i\}_{i=1}^n$. A particular
type $S$ is minimal since all other $T_i$ types are either more
general or equal ($\succeq$), or not related to $S$.
  
Let us now present the typing rule that, given $I\in\V_i$ and
$I:_\darr\land_{i=1}^n\/T_i$, derives the join $\sqcup_{i=1}^n\/T_i$
in order to determine the join ground type of $I$, i.e.,
$I:_\sqcup\land\sqcup_{i=1}^n\/T_i$. Recall from Section
\ref{sec:join-meet-types} that we defined the operation join as the
minimal upper bound of a set $\{T_i\}_{i=1}^n$. A join
$\sqcup_{i=1}^n\/T_i$ is a set of minimal upper bounds
$\{S_j\}_{j=1}^m$ that are related to all types $T_i^{\s/i\in[1,n]}$
via $\preceq$, and are minimal.

\begin{equation}
\label{rul:join-logic}
\dfrac{I\in\V_i,\, \/I:_\darr\land_{i=1}^n\/T_i}
      {\begin{array}{l}
        I:_\sqcup\land\{S \mid \/S\in\TT_i,\,\/T_i^{\s\/i=1..n}\preceq\/S\ \land \\
        \phantom{I:_\sqcup\land\{S \mid\ }\forall\/P\in\TT_i,\,((T_i^{\s\/i=1..n}\preceq\/P\land\/S\preceq\/P)\lor\/P\not\sim\/S)\}
       \end{array}}
\end{equation}

The MUB types are used as the starting points for searching for a
correct schema type. In case a predicate has two alternative
definitions in two different contexts, then a path from a MUB type to
the schema of a KG determines the corresponding schema type. The
details are presented in Section \ref{sec:stored-3types}.






\section{Typing triples\label{sec:triples}}


%\subsection{Triple types\label{sec:3-types}}

A type of a triple $(s,p,o)\in\V_t$ is a product type $D*p*R$
where $s:D$ and $o:R$ holds. In our model, the triple types are
represented by a triple $(D,p,R)\in\TT_t$. The types $D$ and $R$ are
type expressions that represent either a class identifier or an 
expression composed of classes related by $\land$ and/or $\lor$
operators. The available logical operators depend on the schema
languege of a KG. For now, we assume the schema language is
RDF-Schema.

The $\land$-types reflect the semantics of RDF-Schema \cite{rdfschema}
which permits the definition of multiple domains and ranges of the
predicate $p$ that are linked with $\land$-types. Consequently, each
predicate $p$ has exactly one triple type of the form
$$(\land_{i=1}^n\/D_i^{\s\/i=1..n}, p ,\land_{j=1}^m\/R_j).$$

\begin{example}
  If $p$ has two domains $D_1$ and $D_2$, and a single
range type $R$ then the type corresponding to $p$ is
$(D_1\land\/D_2,p,R)$. $\finbox$
\end{example}

\noindent
The interpretation of a triple type $(D,p,R)$ is defined as
follows.
$$\llb(D,p,R)\rrb_\Delta=\{(s,p,o)\mid\/s\in\llb\/D\rrb_\Delta\land\/o\in\llb\/R\rrb_\Delta \}$$

The subtype relationship among the triple types is defined on the
basis of the subtype relationship among classes, $\land$ and
$\lor$-types, and predicates. The following rule defines the
relationship $\preceq$ beween two triple types.

\begin{equation}
\label{rul:3-subtype}
\dfrac{\begin{array}{c}
       T_1\in\TT_t,\ T_1=(D_1,p_1,R_1)\quad T_2\in\TT_t,\ T_2=(D_2,p_2,R_2) \\
       D_1\preceq\/D_2\quad\/p_1\preceq\/p_2\quad\/R_1\preceq\/R_2
       \end{array}}
      {T_1\preceq\/T_2}
\end{equation}

\noindent
The above Rule \ref{rul:3-subtype} handles the $\land$-types of the
subject and object through Rules
\ref{rul:land-preceq-elems}-\ref{rul:land-preceq-ubound}.






\subsection{Ground types of a triple\label{sec:3-ground-types}}

\noindent
The ground types of a triple $t$ are either a stored ground type, a
minimal ground type, or a join ground type. The stored ground type
includes types that are stored in a KG. The minimal ground type then
consists solely of the minimal types from the stored ground
types. Finally, the join ground type is the conjunction of minimal
upper bound types obtained by applying the MUB operator to the conjunction
of minimal ground types \cite{Knudstorp2024}.
 
A ground type of a ground identifier $I$ is a class identifier $T$
related to $I$ by one-step type relationship $:_\darr$, as presented
by Rule \ref{rul:ident-1step-type}. In terms of the concepts of a
knowledge graph, $I$ and $T$ are related by the relation rdf:type.

A ground type of a triple $t=(I_s,p,I_o)$ is a product type
$S*p*T$ that we represent as a triple $(S,p,T)$. A triple type
includes the ground types of $t$'s components $I_s$ and $I_o$, and the
property $p$, which now has the role of a type. The following rule defines a ground type of a triple.

\begin{equation}
\label{rul:3-ground}
\dfrac{\begin{array}{c}
       t\in\V_t,\ t=(I_s,p,I_o) \\
       S,T\in\TT_i\quad I_s:_\darr\/S\quad I_o:_\darr\/T\quad p:_\darr\text{rdf:Property}
       \end{array}}
       {t:_\darr(S,p,T)}
\end{equation}

The types $S$ and $T$ are either class identifiers or $\land$-types
composed of a conjunction of class identifiers. The predicates are
treated differently from the subject and object components of
triples. The predicates have the role of types while they are
instances of rdf:Property.

The minimal ground type of a triple $t$ can be obtained by computing
the minimal ground types of the triple components.

\begin{equation}
\label{rul:3-min-ground}
\dfrac{\begin{array}{c}
       t\in\V_t,\, t=(I_s,p,I_o) \\
       S,T\in\TT_i\quad I_s:_\Darr\/S\quad I_o:_\Darr\/T\quad p:_\darr\text{rdf:Property}
       \end{array}}
      {t:_\darr\/(S,p,T)}
\end{equation}

The component types $S$ and $T$ of the minimal ground type $(S,p,T)$
can represent $\land$-types. The following rule transforms a triple
type including $\land$-types into an $\land$-type of simple triple
types composed of class identifiers in place of the subject and object
components. The rule is expressed in a general form by using the
typing relation "$:$", which can be replaced by any labeled typing
relation.

\begin{equation}
\label{rul:3-land-transform}
\dfrac{t\in\V_t\quad t:(\land_{i=1}^n\/S_i,p,\land_{j=1}^m\/T_j)}
      {t:\land_{i=1..n, j=1..m}(S_i,p,T_j)}
\end{equation}

The type in the conclusion of the rule is constructed by the Cartesian
product of the sets of types belonging to the types of the subject and
object components. Since each of the types $S_i$ and $T_j$ is valid
for the subject and object components of $t$, respectively, then also the triple types from the conclusion of the rule are valid.

The above decomposition of a triple type into a set of triple types is
useful when we check the ground types against the schema triple types
to select the valid schema triple type of a triple. This is detailed in
Section \ref{sec:stored-3types}.

Finally, the join of a set of ground types is a set of MUB types, as
defined in Section \ref{sec:join-meet-types}. Similar to the
previous rules for ground typing, the join is derived by inferring the
join types of the subject and object components of $t$.

\begin{equation}
\label{rul:3-join}
\dfrac{\begin{array}{c}
       t\in\V_t,\ t=(I_s,p,I_o) \\
       S,T\in\TT_i\quad I_s:_\sqcup\/S\quad I_o:_\sqcup\/T\quad p:_\darr\text{rdf:Property}
       \end{array}}
      {t:_\darr\/(S,p,T)}
\end{equation}

The join type $(S,p,T)$ includes in the subject and object components
the $\land$-types composed of one or multiple MUB classes. When we
convert this type into a conjunction of basic MUB triple types. Let's
refer to this $\land$-type as $M$. Each MUB type from $M$ stands for
all ground triple types of~$t$.

We can easily see that each particular triple type from $M$ is an MUB
type since it includes MUB types in its components. Further, the MUB
types from $M$ are incomparable since the MUB types of the components
are incomparable by $\preceq$.

All rules defined for the ground triple types rely on inferring the
types of their components. The reason for this is the stored typing
of ground identifiers as well as the stored subtype relation $\preceq$.
Both are defined solely for classes and predicates.





\subsection{Schema triple types\label{sec:stored-3types}}

The schema types are types of triples defined by a variant of KG
schema. The schema definition language currently used in KGs is either
RDF-Schema \cite{rdfschema} or RDF-Schema combined with OWL
\cite{owl2} vocabulary. In this section, we present the semantics of
both approaches.

We do not expect that the domain and range of the predicate are defined
for each particular predicate $p$. They can be inherited from the
super-predicates of $p$. Hence, a predicate $p$ has the domain and
range defined either directly, when domain and range are defined for
the predicate $p$, or indirectly, if the domain and range are defined
for $p$'s super-predicates and inherited by the predicate $p$.

The rules for the derivation of the schema triple type of a given
triple $t$ are presented for two different schema definition
languages. In Section \ref{sec:stored-3types}.1 we present the
derivation of schema types when the RDF-Schema is used. Further, in
Section \ref{sec:stored-3types}.2 we define the typing rules for
KGs that use RDF-Schema together with $\land$-$\lor$ types.






\subsubsection{KGs with RDF-Schema.}

When the semantics of a KG is defined by using RDF-Schema, we can
specify one or more domain and range types, but no alternative
types. The semantics of RDF-Schema \cite{rdfsemantics} interprets
multiple domains and ranges with $\land$-type. If $p$ has two domains
$T_1$ and $T_2$ then $p$ can link subjects $I$ that are of type $T_1$
\emph{and} $T_2$. The domain type of $p$ is then $T_1\land\/T_2$, or,
in terms of OWL \cite{owl}, owl:intersectionOf$(T_1\ T_2)$. The
RDF-Schema does not allow the definition of the domain or range of a
predicate with the $\lor$-type. Consequently, each predicate can have
only one meaning.

We first determine \emph{all} valid schema types for a given triple
$t=(s,p,o)$. A schema triple type comprises a predicate $p$ and the
domain and range types linked to predicates $p'\succeq\/p$. The domain
and range types can be defined for the predicate $p$ and/or inherited
from the predicates $p'\succ\/p$. In addition, the domain and range
types can be, in general, inherited from two different
super-predicates of $p$.

\begin{equation}
\label{rul:3-stored1}
\dfrac{\begin{array}{c}
       t\in\V_i,\, t=(s,p,o)\quad p_1,p_2\in\TT_p,\, p\preceq\/p_1\preceq\/p_2 \\
       T_i^{\s\/i=1..n}\in\TT_c,\, (p_1,\text{domain},T_i)\in\/\Delta \\
       S_j^{\s\/j=1..m}\in\TT_c,\, (p_2,\text{range},S_j)\in\Delta
       \end{array}}
      {t:_\uarr\/(\land_{i=1}^n\/T_i, p, \land_{j=1}^m\/S_j)}
\end{equation}

The above rule generates pairs of types of the domain and range of a
predicate $p$. We allow that a domain and range types are defined for
different predicates $p_1,p_2\preceq\/p$ since such a situation can
appear in a KG. However, we have to be careful that the rules of
inheritance are respected. We can only inherit from $p_1$ and $p_2$
that are related by subtype relation:
$p\preceq\/p_1\preceq\/p_2$. This condition restricts the domain and
range to be defined on the same path from $p$ to some maximal element
$m$ of the predicate $p$ poset. 


The above Rule \ref{rul:3-stored1} generates all valid schema types of
a triple $t$. From the set of all valid stored types of $t$, we select
the subset including only the minimal types. The following rule is a
logical judgment for a minimal schema type of a $t$. 

\begin{equation}
\label{rul:min-stored-type}
\dfrac{\begin{array}{c}
         t\in\TT_i\quad T\in\TT_t,\, t:_\uarr\/T \\
         S_i^{\s\/i\in[1,n]}\in\TT_t,\, t:_\uarr\/S_i\quad T\preceq\/S_i\lor\/T\not\sim\/S_i
       \end{array}}
      {t:_{\uarr}\/T}
\end{equation}

The first part of the premise says that $t$ is a ground triple and there
exists $T\in\TT_t$ which is a type of $t$. The second part of the premise
requires that $T$ is the minimal type of all types $S$ of $t$. In
other words, there is no type $S_i^{\s\/i=1..n}$ of $t$ that is a
subtype of $T$. Hence, $T$ is the minimal type of the stored triple
types of $t$.

Note that if the schema is defined by using RDF-Schema, and the stored
schema typing is correct, then the condition $T\sim\/S_i$ is always
$true$, and Rule \ref{rul:min-stored-type} generates exactly one
minimal type.

\memo{
Furthermore, under the restrictions of RDF-Schema, we can
not define a predicate $p$ with two meanings. If we were to specify two
different domains or ranges of $p$, then the reasoner would treat the
domain and range types as $\land$-types. Each instance of the domain
(range) type has to be an instance of all specified types of the
domain (range).}

% 



\subsubsection{KGs with the contextual representation.}

The collective findings of the research in the areas of Cognitive
science \cite{Stenning2008,Hollister2017} show that natural language
is inherently contextual, and the context is essential in the human
representation of knowledge and reasoning. Similarly, in the area of
AI reasoning \cite{McCarthy1993,Ghidini2001,Brewka2007}, the context
is essential because the interpretation of propositions, predicates,
and defaults often depend on the local assumptions and domain in which
they are applied.

Most recent KGs enforce exactly one meaning of a predicate in KGs
through the RDF Schema. On the ther hand, the contextual
representation and reasoning allow the definition of multiple senses
of a predicate. There are many motivations for adopting contextual
representation and reasoning in a KG. First, with the evolution of
KGs, there are many examples where a KG is represented in a modular
way, splitting the dataset into parts that correspond to the
contexts. The meaning of a predicate can be different in different
contexts, while the reasoner is able to disambiguate among the
different meanings of a predicate.  The examples of KGs using contexts
include the named graphs in DBpedia \cite{Auer2007}, Wikidata
\cite{vrandecic2014}, and Yago \cite{Hoffart2013}. Another example is
Cyc \cite{cyc} that uses microtheories to represent different
contexts. Similar to Cyc, Scone \cite{Fahlman2011} is a KR system that
can define spaces (contexts) and uses contextual reasoning. Finally,
the $\land$ and $\lor$-types are often implemented in KGs in the form
of OWL type constructors owl:intersectionOf and owl:unionOf. The OWL
union and intersection type constructors are employed mostly in
domain-specific KGs like biomedical and genomic ontologies, where new
classes can be defined as logical combinations of existing classes.

\memo{The second motivation for using contextual representation of KGs are
the problems that appear when a predicate with multiple senses is
represented with multiple sub-predicates. In a query---whether
expressed in natural language, logic or as a database query---it is
difficult to determine the correct (sub-)predicate for the particular
query \cite{cyc}. The alternative is that a user must explicitly
select a correct sense of a predicate (i.e., a sub-predicate) in the
query where the burden of selecting the correct (sub-)predicate is
transfered to a user.}

\memo{Finally, a predicate represents a binary relation. Therefore, it
  can be compared to a function which is a special case of a binary
  relation. In computer science, a function is not represented by its
  name only, but with a function type including, besides the function
  name, also the types of its domain and range. In programming
  languages, functions disambiguate among the different functions with
  the same name but different domain and range types. Similarly, the
  types can be effectively used to disambiguate the meaning of the
  predicate in a KG.}

To be able to study the behavior of KG predicates with multiple senses
in the presence of triple types, we propose a minimal KG schema
language that includes the triple types stored in a KG as triples. If
there is more than one schema type with a predicate $p$, then they are
treated as alternatives.

\begin{example}
  Suppose a KG includes the schema types $(T_1,p,T_2)$ and
  $(T_3,p,T_4)$, where $T_j^{\s\/j=1..4}\in\TT_i$. The schema type of
  ground triples with  $p$ is
  $(T_1,p,T_2)\lor\/(T_3,p,T_4)$. $\finbox$
\end{example}

Further, the proposed KG schema language can use $\land$-$\lor$ types
in subject and object components of triple types. The use of
$\lor$-type in place of the domain or range type is redundant since
the disjunction can be expressed with multiple triple types. Hence,
the \emph{minimal KG schema language} includes solely the triple types
of the form $(\land_{i=1}^n\/S_i,p,\land_{j=1}^m\/T_j)$, where
$S_i^{\s\/i=1..n}\in\TT_c$ and $T_i^{\s\/i=1..m}\in\TT_l\cup\TT_c$.

Let us now present the rules that derive the schema type of a ground
triple $t$ in the case our minimal KG schema language is used. First,
the following Rule \ref{rul:3-stored2} generates all valid
alternatives of stored triple types given a triple $t$. 

\begin{equation}
\label{rul:3-stored2}
\dfrac{\begin{array}{c}
       t\in\V_t,\, t=(s,p,o) \\
       T_i^{\s\/i=1..n}\in\TT_t,\, T_i=(D_i,p,R_i)\quad\/T_i^{\s\/i=1..n}\in\Delta
       \end{array}}
       {t:_\uarr\/\lor_{i=1}^n\/T_i}
\end{equation}

The above rule states that the \emph{stored types} of $t$ are the
triple types $T_i\in\TT_t\land T_i\in\DD$ including a predicate
$p$. Note that $D_i$ and $R_i$ are the types of domains and ranges of
$p$ that can stand for an $\land$-type. A triple type
$\lor_{i=1}^nT_i$ of $t$ is a disjunction of all valid stored triple
types of $t$.

Similar to Rule \ref{rul:min}, which is defined to find the minimal
types of a set of classes, the following Rule~\ref{rul:3-min}
generates the disjunction of minimal schema types.

\begin{equation}
\label{rul:3-min}
\dfrac{t\in\V_t\quad\/t:_\uarr\lor_{i=1}^n\/T_i}
      {t:_{\uarr}\lor\{S \mid S\in\/\{T_i\}_{i=1}^n\land\forall\/i=1..n,\, S\preceq\/T_i\lor\/S\not\sim\/T_i\}}
\end{equation}

The rule says that the triple types $S$ are minimal schema types of a
schema type $\lor_{i=1}^n\/T_i$. $S$ is minimal since all other
types $T_i$ are either more general or equal ($\succeq$), or not
related to $S$. 





\subsection{Typing a triple}

Before we present the final step in typing a triple $t$, an overview
of the work done so far is given. First, we derive the ground type of
the triple $t$ and then infer the minimal upper bound of the ground
type. The ground typing inspects all ground types of $t$'s
components. In case the MUB type is close to the $\top$ type, then
there is an outlier in the set of ground types that can be revealed in
the computation of the MUB type.

Second, the schema type of $t$ is derived from the schema of a KG. In
case we use RDF-Schema semantics of a KG, then the rules infer a
single minimal schema type. If there is more than one schema type,
then the domains and ranges from the different definitions are merged
into one $\land$-type. At this point, we can not verify if there are
any errors in types from the domain and/or range of a predicate. In
case we use RDF-Schema with $\land$-$\lor$ types, then the rules can
infer multiple disjunctive schema types. Also in this case, there are
no additional constraints that could be verified.

Let us now present the final typing of $t$ by relating the ground type
of $t$ with the minimal schema type of $t$ via the subtyping relation
$\preceq$. If the RDF-Schema semantics are used, then we have a single
schema type which should be related to the ground type of $t$. The
following Rule \ref{rul:3-typing-one} derives the final type of $t$
under RDF-Schema semantics.

\begin{equation}
\label{rul:3-typing-one}
\dfrac{t\in\TT_i\quad T\in\TT_t,\, t:_{\darr}T\quad S\in\TT_t,\, t:_\uarr\/S\quad T\preceq\/S}
      {t:S}
\end{equation}

The type of $t$ is computed by first deriving the ground type $T$ and
the schema type $S$ of $t$. $S$ is the final type of $t$ if $T$ is a
subtype of $S$. In case $T\not\preceq\/S$, then the ground type
$T=\land[T_i^{i\in[1,n}]$ includes at least one $T_i\not\preceq\/S$.

Let's now assume that we use the \emph{minimal KG schema language}, as
defined in Section \ref{sec:stored-3types}.2, for the representation
of the KG schema. Note also that we have to use Rules
\ref{rul:3-stored2}-\ref{rul:3-min} in order to derive the schema
triple type. The rule for selecting the final type of $t$ is now as
follows.

\begin{equation}
\label{rul:3-typing-two}
\dfrac{t\in\TT_i\quad t:_{\darr}T\quad\/t:_\uarr\lor_{j=1}^{m}\/S_j}
      {t:\lor_{j=1}^m\{S_j \mid T\preceq\/S_j\}}
\end{equation}

Only those types $S_j$ that are linked to $T$ via the poset hierarchy
of types are gathered in the final type. This means that the ground
triple selects, via its type, the meaning of the predicate $p$.

The examples of final types that include more than one alternative
schema type with different meanings can appear when typing triple
patterns. In case a triple pattern $tp$ contains one or more
variables, then the ground type of one or more $tp$'s components can
not be derived; hence, the $\top$ type is used. Consequently, the
ground type of the triple pattern may match more than one schema type.






\section{Related work\label{sec:related}}

Most of the related work is cited in the text when presenting the
particular topic. In this section, we present only the work that is not
directly related to the presented work but represents a contribution
to the typing of the knowledge graphs.

The entity typing and type inference deal with predicting and
inferring the types (classes) of entities that are either missing or
incorrect. The automatic type assignment can use logic-based
assignment where a reasoner infers the type of an entity from the
schema \cite{Horrocks2003}. Alternatively, the rule-based inference
can be employed on the rules defined as a schema by knowledge
engineers \cite{Horrocks2004}. Reasoners use them
automatically. Another alternative is the use of ML-based type
prediction \cite{Yaghoobzadeh2018}. Various techniques can be used,
like entity embeddings and graph neural networks, to produce
embeddings to be fed into the classifier.

The schema-based type checking is about the verification of RDF-Schema
\cite{rdfschema12} and OWL \cite{owl2} rules and constraints against
the data (ABox) and schema (TBox) parts of a KG
\cite{Baader2002,Horrocks2003,OWL2Spec2012}. The domain and range
types of predicates are checked to determine whether they are correctly interpreted
among the ground triples of a KG. The consistency of subtyping and
inheritance is verified in the KG schema and in the data. Similarly,
the disjointness of types and other OWL constraints is
checked. Most of the presented themes are covered by tools based on
SHACL \cite{shacl2017} and ShEx \cite{shex2015}.

Type checking in query answering ensures that the variables and
results of a query over a KG are consistent with the schema of a KG
\cite{Zhao2017,Zhang2019}. A type-checker for queries requires that a
query respects class hierarchies, domain/range constraints, and
disjointness rules. All type manipulation in \cite{Zhao2017,Zhang2019}
is at the level of SparQL \cite{sparql} variables. This means, for
example, that triple patterns do not have type, so there is no way to
reason about typing of triples. Also, the union and intersection types
are used directly, without the means to manipulate $\land$-$\lor$ type
expressions.

The type information can also be used to improve the query
optimization and execution. In \cite{Kollia2013}, they propose to
leverage type information to optimize query execution and filter
semantically invalid results. In most cases, the presented approaches
use fragments of types that are adapted for the particular problem.





\section{Conclusions\label{sec:conclude}}

The implementation of typing a knowledge graph is currently underway
in the context of a working prototype RDF store \epsln
\cite{epsilon2025}, which is used for browsing and querying knowledge
graphs, particularly the schema component. \epsln has also been used
as a prototype environment for computing type-based statistics of KGs
based on types \cite{Savnik2025}.

The \epsln environment includes a simple language for the manipulation
of the sets of identifiers and triples. Algebraic operations are
used for mapping sets to new sets by using single predicates, path
expressions, or, transitive closure operations with fine control over
the computation of closures. Additionally, operations on posets of
identifiers and triples are being implemented to compute minimal and
maximal elements, the MUB and MLB as well as LUB and GLB. The
typing rules are implemented as procedures whitin this framework.


\section{Acknowledgments}
The author acknowledge the financial support from the Slovenian
Research Agency (research core funding No. P1-00383).


\bibliographystyle{apalike}
{\small
\bibliography{biblio}}

\end{document}



