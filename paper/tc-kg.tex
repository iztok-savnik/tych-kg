\documentclass[runningheads]{llncs}

\pdfoutput=1
\usepackage{times}
\normalfont
\usepackage{latexsym}
\usepackage[T1]{fontenc}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphics}
\usepackage{color}
\usepackage{url}

% symbols
\newcommand{\D}{{\cal D}} 
\newcommand{\I}{{\cal I}} 
\newcommand{\Ii}{{\cal I}_i} 
\newcommand{\Ic}{{\cal I}_c} 
\newcommand{\Ip}{{\cal I}_p}
\newcommand{\T}{{\cal T}}
\newcommand{\Ti}{{\cal T}_i}
\newcommand{\cl}{\text{:}} 
\newcommand{\rdftype}{\text{rdf:type}} 
\newcommand{\rdfsubcl}{\text{rdfs:subClassOf}} 
\newcommand{\rdfsubclpl}{\text{rdfs:subClassOf+}} 
\newcommand{\rdfsubprop}{\text{rdfs:subPropertyOf}} 
\newcommand{\rdfsubproppl}{\text{rdfs:subPropertyOf+}} 
\newcommand{\rdfsdomain}{\text{rdfs:domain}} 
\newcommand{\rdfsrange}{\text{rdfs:range}} 
\newcommand{\finbox}{\phantom{.}\hfill\Box}
\newcommand{\nl}{\hfill\break}
\newcommand{\vb}[1]{\begin{small}\texttt{#1}\end{small}}
\newcommand{\lub}{l}
\newcommand{\memo}[1]{}
\newcommand{\notes}[1]{\noindent\begin{small}-- \emph{#1}\\\end{small}}

\def\ojoin{\setbox0=\hbox{$\bowtie$}%
  \rule[-.02ex]{.25em}{.4pt}\llap{\rule[\ht0]{.25em}{.4pt}}}
\def\leftouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie}}
\def\rightouterjoin{\mathbin{\bowtie\mkern-5.8mu\ojoin}}
\def\fullouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie\mkern-5.8mu\ojoin}}

\pagestyle{headings}
\setcounter{tocdepth}{5} %show more in the toc

\begin{document}

\title{Type-checking knowledge graphs}

\author{Iztok Savnik\inst{1}} 

\authorrunning{I. Savnik et al.}

\institute{Faculty of mathematics, natural sciences and information technologies, \\
  University of Primorska, Slovenia \\
  \email{iztok.savnik@upr.si}}

\maketitle

\begin{abstract}
  We first present a formal view of a knowledge graph. On this basis,
  the type-checking rules are developed to define correct typing
  relationships among the triples of a knowledge graph. We discuss the
  algorithms for verifying the typing relationships against the given
  knowledge graph. Finally, we present the experimental results of
  type-checking the Yago4 knowledge graph.

\keywords{RDF stores \and graph databases \and knowledge graphs \and database statistics \and statistics of graph databases.}
\end{abstract}

%\newpage
%\tableofcontents
%\newpage

\thispagestyle{headings}
\tableofcontents
\newpage

\section{Introduction}

This is intro... \cite{Hogan22KGsSurveyCsur}.





\section{Definition of knowledge graph}

This section defines a knowledge graph as a RDF graph \cite{rdf} using
RDF-Schema \cite{rdfschema} for the representation of the structural
part of a knowledge base.

Let $I$ be the set of URI-s, $B$ be the set of blanks and $L$ be the
set of literals. Let us also define sets $S = I\cup\/B$, $P = I$, and
$O = I\cup\/B\cup\/L$.

Let $I$ be the set of URI-s, $B$ the set of blanks and $L$ be the set
of literals. Let us also define sets $S = I\cup\/B$, $P = I$, and
$O = I\cup\/B\cup\/L$.

\emph{RDF triple} is a triple $(s,p,o)\in\/S\times\/P\times\/O$.
\emph{RDF graph} $g\subseteq\/S\times\/P\times\/O$ is a set of
triples. Set of all graphs will be denoted as $G$. We suppose the
existence of a set of variables $V$ and the set of \emph{terms}
$T = O\cup\/V$. Term $t\in\/T$ is ground if $t\in\/O$.

We say that RDF graph $g_1$ is \emph{sub-graph} of $g_2$, denoted
$g_1 \sqsubseteq g_2$, if all triples in $g_1$ are also triples from
$g_2$. 

\notes{Define major structure of KG on the basis of the sorts of data.}
\notes{...the set $I$ includes individual identifiers $I_i$, class identifiers $I_c$ and predicate identifiers $I_p$.}










\section{Type system used}

\subsection{Product types}

\subsection{Intersection type}

The instances of the intersection type $T_1\land\/T_2$ are objects
belonging to both $T_1$ and $T_2$. The type $T_1\land\/T_2$ is the
greatest lower bound of the types $T_1$ and $T_2$. In general,
$\land[T_1\ldots\/T_n]$ is the greatest lower bound of types
$T_1\ldots\/T_n$ \cite{Pierce91IntersectUnion,Pierce96IntersectionTypes}.

\begin{equation}
T_1\land\/T_2\preceq\/T_1    
\end{equation}

\begin{equation}
T_1\land\/T_2\preceq\/T_2  
\end{equation}

\begin{equation}
\land[T_1\ldots\/T_n] \preceq\/T_i  
\end{equation}

If the type $S$ is more specific than the types $T_1\ldots\/T_n$ then
$S$ is more specific then $\land[T_1\ldots\/T_n]$. First, we present
the rule for a pair of types $T_1$ and $T_2$.

\begin{equation}
\dfrac{S\preceq\/T_1\quad\/S\preceq\/\/T_2}
      {S\preceq\/T_1\land\/T_2}  
\end{equation}

\begin{equation}
\dfrac{\text{forall i,\ } S\preceq\/T_i}
      {S\preceq\land[T_1\ldots\/T_n]}  
\end{equation}

\subsection{Union type}

The intersection and union types are dual. This can be seen also from
the rules that are used for each particular type.

The instances from the union type $T_1\lor\/T_2$ are either the
instances of $T_1$ or $T_2$, or the instances of both types. The type
$T_1\lor\/T_2$ is the smallest upper bound of the types $T_1$ and
$T_2$. In general, $\lor[T_1\ldots\/T_n]$ is the smallest upper bound
of types $T_1\ldots\/T_n$ \cite{Pierce90CalculusIntersectUnion}.

\begin{equation}
T_1\preceq\/T_1\lor\/T_2    
\end{equation}

\begin{equation}
T_2\preceq\/T_1\lor\/T_2  
\end{equation}

\begin{equation}
T_i\preceq\/\lor[T_1\ldots\/T_n]  
\end{equation}

If the type $T$ is more general than the types $S_1\ldots\/S_n$ then
$T$ is more general then $\lor[S_1\ldots\/S_n]$. First, we present
the rule for types $T_1$ and $T_2$.

\begin{equation}
\dfrac{S_1\preceq\/T\quad\/S_2\preceq\/\/T}
      {S_1\lor\S_2\preceq\/T}  
\end{equation}

\begin{equation}
\dfrac{\text{forall i,\ } S_i\preceq\/T}
      {\lor[S_1\ldots\/S_n]\preceq\/T}  
\end{equation}






\section{Typing identifiers}

\notes{Introduction includes the formalization of RDF, RDF-Schema as given in Angles and Peres.}
\notes{Typing idents without considering and info about the triples.}

\notes{General.}
\notes{At the end of section define the lub type using $\land$/$\lor$ types.}
\notes{1. Define lub types as the closest to base types of given ground ident.}
\notes{2. Collect all lub types using $\land$ type in a single type.}

\notes{Details.}
\notes{1. First define base type of identifiers $:_1$ and stored subtyping relationship $\preceq_1$.}
\notes{2. From the basis define the indent typing $:$ and subtyping rel $\preceq$ among identifiers.}
\notes{3. Include the link between subtyping and typing.}
\notes{4. Define lub type using $\land$ type for a given ground ident.}




\subsection{Typing literals}

\notes{Literals are identifiers of atomic type!}





\subsection{Stored typing and subtyping of identifiers.}\nl

\notes{Partial ordering defined with stored schema triples in a database.}
\notes{The relationships that poset $\preceq_1$ covers are rdfs:subClassOf and rdfs:subPropertyOf. }
\notes{Identifiers included in $:_1$ are between ground idents and base classes.}
\notes{This allows us to separate and also address separately the ssg and subtyping relationship.}

\notes{Notes.}
\notes{Oportunity to introduce ``mixed'' objects including ground and schema components.}


\noindent Reflecting the one-step relationship rdf:type with $:_1$. 

\begin{equation}
\dfrac{I_1\in\Ii \quad I_2\in\Ic \quad (I_1,\text{rdf:type},I_2)\in \D}
      {I_1 :_1 I_2}
\end{equation}

Expressing the one-step subtyping relationship rdfs:subClassOf with $\preceq_1$.

\begin{equation}
\dfrac{I_1,I_2\in\Ic \quad (I_1,\text{rdfs:subClassOf},I_2)\in \D}
{I_1 \preceq_1 I_2}
\end{equation}

Expressing the one-step subtyping relationship rdfs:subPropertyOf with $\preceq$.

\begin{equation}
\dfrac{I_1,I_2\in\Ip \quad (I_1,\text{rdfs:subPropertyOf},I_2)\in \D}
      {I_1\preceq_1\/I_2}
\end{equation}




\subsection{Typing and subtyping identifiers.}\nl

\notes{Extend one-step relationships $:_1$ and $\preceq_1$ to relationships $:$ and $\preceq$.}
\notes{The relation $\preceq$ is the relation $\preceq_1$ extended with the reflexivity and transitivity.}
\notes{Link typing $:$ and subtyping $\preceq$ with a rule.}



\noindent
Generalizing one-step relationship $\preceq_1$ to the relationship
$\preceq$.

\begin{equation}
\dfrac{I_1,I_2\in\I \quad I_1\preceq_1 I_2}
      {I_1 \preceq I_2}
\end{equation}

Subtyping is reflexive.

\begin{equation}
\dfrac{S\in \I}
      {S\preceq\/S}
\end{equation}

The subtype relationship is transitive. We require that the
symbols $S$, $U$ and $T$ are identifiers. Note that $S$ can be an
individual identifier while $U$ and $T$ have to represent
classes.

\begin{equation}
\dfrac{S,U,T\in\I \quad S\preceq\/U \quad U\preceq\/T}
      {S\preceq\/T}   
\end{equation}

Types include a special type $\top$ that represents the most
general type in the ontology. Every type is more specific than the top
type $\top$.

\begin{equation}
S\preceq\top
\end{equation}

%\subsection{Typing of identifiers.}

A base type of an individual identifier $I$ is a type of $I$.

\begin{equation}
\dfrac{I\in\Ii \quad C\in\Ic \quad I:_1\/C}
      {I:C}
\end{equation}

The link between the typing relation and subtype relation is
provided by adding a new typing rule \cite{Pierce02TypesProgLang}. The
following rule is called \emph{rule of subsumption}.

\begin{equation}
\dfrac{I\in\Ii \quad I:S \quad S\preceq\/T}
      {I:T}    
\end{equation}


\notes{Properties have dual role: they are instances and types at the same time.}
\notes{Present the features of properties from this point of view.}


\notes{Put together the base types of ground identifiers using $\land$ type.}
\notes{First, the base type of an ground identifier is the $\land$ of all base types.}
\notes{The \emph{base type} of a ground identifier is defined explicitely!}

\notes{The lub types of base types B are the smallest types related to all base types.}
\notes{The lub types are related by $\land$ to form a (complete) type of a ground identifier.}
\notes{The complete type of a ground identifier is defined explicitely.}








\section{Typing triples}

%\notes{Show the complete poset of triples.}
%\notes{Define the set of ground triples.}
%\notes{Define the set of type triples (schema triples) and the schema graph .}
%\notes{Define the stored schema graph.}

\notes{There are two basic aspects of a triple type.}
\notes{First, the type is computed bottom-up: from the stored types of triple components.}
\notes{Second, the type can be computed top-down: from the user-defined domain/range types of properties.}

\notes{Ground type of a triple is computed first using $:_1$.}
\notes{Next, the lub type of a triple is derived using $:_l$.}
\notes{From the top side of the ontology, the stored type $:_s$ is determined based on $p$.}
\notes{Finally, the type $:$ of $t$ is deterimned by summing alternative $:_s$ types.}

\notes{Interactions between the $\land/\lor$ types of triple components and triples must be added.}
\notes{Analogy between. the types of functions in lambda calculus and types of triples.}
\notes{Show rules relating $\land/\lor$ types and triple types. Example.}
\notes{E.g., $(S_1\land\/S_2)*p*R = S_1*p*R\land\/S_2*p*R$.}




\subsection{Deriving a base type of a triple.}

\memo{\noindent The base type of an individual identifier $i$ is a
  class $c$ related to $i$ by one-step relationship $\preceq_1$. In
  terms of the concepts of a knowledge graph, $c$ and $i$ are related
  by the relationship rdf:type.}

A base type of a triple $t=(s,p,o)$ is a triple $T=T_s*p*T_o$ that
includes the base types of $t$'s components $s$ and $o$, and the
property $p$ which now has the role of a type. A base type of a triple
is defined by the following rule.

\begin{equation}
  \label{rul:3-ground}
\dfrac{t=(s,p,o)\quad s:_1T_s\quad p:_1\text{owl:ObjectProperty}\quad o:_1T_o}
      {t:_1T_s*p*T_o}
\end{equation}

The type of S component $T_s$ is one of the ground types of $s$, and
the type of O components is one of the ground types of $o$. The
predicate $P$ is treated differently to S and O components. The
predicates have the role of classes while they are instances of
owl:ObjectProperty.

There are multiple ground types of a triple. They can be gathered into
a single type using the $\land$ type.

\begin{equation}
\dfrac{t\in \Ti\quad \forall\ i, t:_1T_i}
      {t:_\land\bigwedge[T_1..T_n]}
\end{equation}


\notes{Ground typing by using lub types of $T_1..T_n$.}
\notes{Is this really needed?}


Let us now select the least upper bound types of the ground types
derived by the rule \ref{rul:3-ground}.

\begin{equation}
\dfrac{t:_1\bigwedge[T_1..T_n]\quad \forall\/i, T_i\preceq\/T}
      {\vdash\/t:_{\land1}\/T}
\end{equation}


\notes{Now only the minimal types have to be selected.}


\begin{equation}
\dfrac{t:_{\land1}\/T\quad \forall(t:_\land\/S), S\preceq\/T}
      {t:_{\land2}\/T}
\end{equation}


\notes{Finally, lub2 types are gathered with $\land$.}


\begin{equation}
\dfrac{\quad \forall i, t:_{\land2}\/T_i}
      {t:_\land\/T}
\end{equation}


\memo{The types of $s$ and $o$ can be any classes $T_s$ and $T_o$ from
  ${\cal I}_c$, while the type of $p$ has to be a class $T_p$ that is
  a subclass of rdf:Property. The typing of a triple $t$ is correct
  since the interpretation of $T$ includes $t$.}

\memo{Moreover, the types $T$ that are derived by the above rule are
  minimal in the sense that given the information provided, i.e., the
  types of $t$'s components, their interpretations are minimal
  possible comparing them to the interpretations of all other derived
  types of $t$.}






\subsection{Stored types of triples.}\nl

\notes{Make a bit more clear picture of the GLB triple types selected as the final stored type of a triple.}
\notes{Analysis tool. Show minimality of the stored types (either enumerated of gathered with $\bigvee$).}
\notes{\emph{Reminder:} when a complete stored (user-defined) type is related to the base type of a triple, some of GLB types may be eliminated.}

\notes{Predicates should be treated in the same way as the classes.}
\notes{They can have a rich hierarchy.}
\notes{\emph{Note:} Where to include discussion on special role of predicates and their relations to classes?}

We first find a stored schema triples for a given triple $t=(s,p,o)$. A
stored schema triple is constructed by selecting types including a
predicate that have the domain and range defined.

\begin{equation}
\label{rul:3-stored}
\dfrac{t\in\Ti,t=(s,p,o)\quad p\preceq\/p'\quad (p',\text{domain},T_s)\in\/g\quad (p',\text{range},T_o)\in\/g}
      {t:_s(T_s,p,T_o)}
\end{equation}


\medskip
%\notes{Generator view of rules: Just describe the properties of pre-conditions and conclusions for a particular lub type of triple.}
\notes{Comments and description of the above rule.}

The domain and range of a predicate $p$ can be defined for any
super-predicate, they do not need to be defined for $p$. In addition,
the domain and range of a predicates do not need to be defined for the
same predicate; they can be defined for any of the super-predicates
separately. The following rule captures also the last statement.

\begin{equation}
\label{rul:3-stored1}
\dfrac{t=(s,p,o)\quad p\preceq\/p_1\quad p\preceq\/p_2\quad (p_1,\text{domain},T_s)\in\/g\quad (p_2,\text{range},T_o)\in\/g}
      {t:_s(T_s,p,T_o)}
\end{equation}

\notes{If $p$ inherits from multiple $p'\succeq\/p$, then the above rule generates multiple types. Explain.}

Note that the type is determined only in the case that the domain and
range of $p$ or some $p'\succeq\/p$ is defined. Otherwise, the domain
and range shoud be $\top$. 

The following rule is a judgment for a (user-defined) type of a
concrete triple $t=(s,p,o)$. A user-defined type of $t$ is the
greatest lower bound of stored types generated by the rule
\ref{rul:3-stored1}.

\notes{A general explanation for choosing glb type should be given. Further expanded below. (?)}

\begin{equation}
\dfrac{t\in\Ti\quad t:_s\/T\quad\forall\/S, t:_s\/S\land\/T\preceq\/S}
      {t:_\lor\/T}
\end{equation}


The first premise says that $t$ is an individual triple. The second
premise determines one of the stored type $T$ of $t$. The third
premise requires that the user-defined type $T$ is the least general
type.

The implementation view of the above rule is as follows. The schema
triples are obtained from the inherited values of the predicates
rdfs:domain and rdfs:range. The inherited values have to be the
closest when traveling from property $p$ towards the more general
properties.

\medskip
\notes{Why do we have multiple glb types? Add explanation.}
\notes{(The following paragraph is not completed! More precise!)}

Multiple different schema triples for a given $t$ are possible only in
the case of multiple inheritance, in the case of the definition of the
disjunctive domain/range types, or if predicate is defined for
semantically different concepts. (describe each possibility in more
detail.)


\medskip
\notes{Add explanation about why glb types are connected with $\lor$.}
\notes{$\lor$ is used since they represent alternative semantics of a triple.}
\notes{When type-checking a language, a context can be used to resolve disjunctions.}

Now we can put together the greatest lower bounds of the top types by
making the union of the glb types computed by the previous rule.

\begin{equation}
\dfrac{t\in\Ti\quad \forall\/i, t:_\lor\/T_i}
      {t:_\lor\bigvee\/T_i}
\end{equation}

\medskip
\notes{Expand on the influence/effect of using $\bigvee$ type in context and in other rules.}






\subsection{Typing a triple.}\nl

\notes{Two ways of defining semantics.}
\notes{1) enumeration style: stored types are enumerated as alternatives ($\lor$).}
\notes{2) packed together: alternative types are packed in one $\bigvee$ type.}
\notes{One advantage of (1) is that individual glb types can be processed further individually.}
\notes{Advantage of (2) is the higer-level semantics without going in implementation.}

\notes{Now stored types have to be related to all lub base types to represent the correct type of a triple.}
\notes{It seems it would be easier to check the pairs one-by-one using (1) in algorithms.}
\notes{In case of using complete types in the phases, types would further have to be processed by $\land,\lor$ rules.}

The type of a triple $t=(s,p,o)$ is computed by first deriving the
base type $T$ and the top type $S$ of $t$. Then, we check if $S$ is
reachable from $T$ through the sub-class and sub-property hierarchies,
i.e., $T\preceq\/S$.

\begin{equation}
\dfrac{(s,p,o):_1T\quad (s,p,o):_2S\quad (T\preceq\/S)}
      {(s,p,o):S}
\end{equation}

\medskip

\medskip
\notes{How to compute $T\preceq\/S$? Refer to position where we have a description.}
\notes{Order the possible derivations, gatherings (groupings) ... of types.}

\notes{Possible diagnoses.}
\notes{Components not related to a top type of a triple?}
\notes{Components related to sub-types of a top type?}
\notes{Above pertain to all components.}





\section{Typing a graph.}\nl

\notes{What is a type of a graph?}
\notes{A type of a graph is a graph!}
\notes{It includes a set of schema triples forming a schema graph.}

\notes{Typing a graph bottom-up?}
\notes{Checking that all the triples are of correct types.}


\subsection{Typing a schema triple.}\nl

\notes{What can be checked?}
\notes{Is a schema triple properly related to the super-classes and types of components.}
\notes{Consistency of the placement of a class in an ontology. What is this?}
\notes{A class or predicate component not related to other classes?}
\notes{A class or predicate component attached to ``conflicting'' set of classes? What can be detected?}
\notes{@kiyoshi Do you see any other examples?}
\notes{}





\section{Empirical analysis}




\section{Conclusions}



% \section{Acknowledgments}
%
%The authors acknowledge the financial support from the Slovenian Research Agency (research core funding No. P1-00383).

\bibliographystyle{abbrv}
\bibliography{biblio}

\end{document}



= rules for identifiers
- assumtions
. suppose we have I, a set of identifiers from g
. suppose we have a 

- type-check literals


.................before 05/27/22....................

= (task) general picture
- we have graph pattern 
. a set of triples including consts and vars
- we derive types of TPs



- we derive types of GPs


= (task) determine a type of a TP
. type of TP without a predicate? use rdf:predicate.
. type of TP without the schema? use generalizations.
. type of TP with predicate? use a triple type defined as the schema.
. type of TP can be \cup of triple types (defined in the schema).


= (task) compute a type of a GP
. meeting points in GP: use \cap type constructor
. \cap of \cup of triple types can select one of triple types
. one triple type is selected by other oper of \cap


= (task) compute the type of a concrete triple
- we need a type of a concrete triple, e.g. for distribution
. if we have schema triple than it can be utilized
. obtain the type of each constant
. schema type, or, the most specific type?
